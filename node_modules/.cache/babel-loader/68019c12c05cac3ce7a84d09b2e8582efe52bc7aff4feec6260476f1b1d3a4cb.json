{"ast":null,"code":"\"use strict\";\n\nconst http = require(\"http\");\nconst https = require(\"https\");\nconst {\n  Writable\n} = require(\"stream\");\nconst zlib = require(\"zlib\");\nconst ver = process.version.replace(\"v\", \"\").split(\".\");\nconst majorNodeVersion = Number.parseInt(ver[0]);\nfunction abortRequest(clientRequest) {\n  clientRequest.destroy();\n  clientRequest.removeAllListeners();\n  clientRequest.on(\"error\", () => {});\n}\nmodule.exports = class Request extends Writable {\n  constructor(url, clientOptions, requestOptions) {\n    super();\n    Object.assign(this, clientOptions);\n    this.currentURL = url;\n    this._requestOptions = requestOptions;\n    this.headers = requestOptions.headers;\n    this._ended = false;\n    this._redirectCount = 0;\n    this._requestBodyBuffers = [];\n    this._bufferIndex = 0;\n    this._performRequest();\n  }\n  abort() {\n    abortRequest(this._currentRequest);\n    this.emit(\"abort\");\n    this.removeAllListeners();\n  }\n  pipeRequest(form) {\n    form.pipe(this._currentRequest);\n  }\n  write(data, encoding) {\n    if (data.length > 0) {\n      this._requestBodyBuffers.push({\n        data,\n        encoding\n      });\n      this._currentRequest.write(data, encoding);\n    }\n  }\n  end() {\n    this.emit(\"request\", this._currentRequest);\n    this._ended = true;\n    this._currentRequest.end();\n  }\n  setHeader(name, value) {\n    this.headers[name] = value;\n    this._currentRequest.setHeader(name, value);\n  }\n  removeHeader(name) {\n    delete this.headers[name];\n    this._currentRequest.removeHeader(name);\n  }\n\n  // Without this method, the test send-redirect-infinite-sync will halt the test suite\n  // TODO: investigate this further and ideally remove\n  toJSON() {\n    const {\n      method,\n      headers\n    } = this._requestOptions;\n    return {\n      uri: new URL(this.currentURL),\n      method,\n      headers\n    };\n  }\n  _writeNext(error) {\n    if (this._currentRequest) {\n      if (error) {\n        this.emit(\"error\", error);\n      } else if (this._bufferIndex < this._requestBodyBuffers.length) {\n        const buffer = this._requestBodyBuffers[this._bufferIndex++];\n        if (!this._currentRequest.writableEnded) {\n          this._currentRequest.write(buffer.data, buffer.encoding, this._writeNext.bind(this));\n        }\n      } else if (this._ended) {\n        this._currentRequest.end();\n      }\n    }\n  }\n  _performRequest() {\n    var _this = this;\n    const urlOptions = new URL(this.currentURL);\n    const scheme = urlOptions.protocol;\n\n    // browserify's (http|https).request() does not work correctly with the (url, options, callback) signature. Instead\n    // we need to have options for each of the URL components. Note that we can't use the spread operator because URL\n    // instances don't have own properties for the URL components.\n    const requestOptions = {\n      ...this._requestOptions,\n      agent: this.agents[scheme.substring(0, scheme.length - 1)],\n      protocol: urlOptions.protocol,\n      hostname: urlOptions.hostname,\n      port: urlOptions.port,\n      path: urlOptions.pathname + urlOptions.search\n    };\n    const {\n      request\n    } = scheme === \"https:\" ? https : http;\n    this._currentRequest = request(requestOptions, response => {\n      this._processResponse(response);\n    });\n    let cookies;\n    if (this._redirectCount === 0) {\n      this.originalCookieHeader = this.getHeader(\"Cookie\");\n    }\n    if (this.cookieJar) {\n      cookies = this.cookieJar.getCookieStringSync(this.currentURL);\n    }\n    if (cookies && cookies.length) {\n      if (this.originalCookieHeader) {\n        this.setHeader(\"Cookie\", this.originalCookieHeader + \"; \" + cookies);\n      } else {\n        this.setHeader(\"Cookie\", cookies);\n      }\n    }\n    for (const event of [\"connect\", \"error\", \"socket\", \"timeout\"]) {\n      this._currentRequest.on(event, function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        _this.emit(event, ...args);\n      });\n    }\n    if (this._isRedirect) {\n      this._bufferIndex = 0;\n      this._writeNext();\n    }\n  }\n  _processResponse(response) {\n    const cookies = response.headers[\"set-cookie\"];\n    if (this.cookieJar && Array.isArray(cookies)) {\n      try {\n        cookies.forEach(cookie => {\n          this.cookieJar.setCookieSync(cookie, this.currentURL, {\n            ignoreError: true\n          });\n        });\n      } catch (e) {\n        this.emit(\"error\", e);\n      }\n    }\n    const {\n      statusCode\n    } = response;\n    const {\n      location\n    } = response.headers;\n    // In Node v15, aborting a message with remaining data causes an error to be thrown,\n    // hence the version check\n    const catchResErrors = err => {\n      if (!(majorNodeVersion >= 15 && err.message === \"aborted\")) {\n        this.emit(\"error\", err);\n      }\n    };\n    response.on(\"error\", catchResErrors);\n    let redirectAddress = null;\n    let resendWithAuth = false;\n    if (typeof location === \"string\" && location.length && this.followRedirects && statusCode >= 300 && statusCode < 400) {\n      redirectAddress = location;\n    } else if (statusCode === 401 && /^Basic /i.test(response.headers[\"www-authenticate\"] || \"\") && this.user && this.user.length) {\n      this._requestOptions.auth = `${this.user}:${this.pass}`;\n      resendWithAuth = true;\n    }\n    if (redirectAddress || resendWithAuth) {\n      if (++this._redirectCount > 21) {\n        const redirectError = new Error(\"Maximum number of redirects exceeded\");\n        redirectError.code = \"ERR_TOO_MANY_REDIRECTS\";\n        this.emit(\"error\", redirectError);\n        return;\n      }\n      abortRequest(this._currentRequest);\n      response.destroy();\n      this._isRedirect = true;\n      if ((statusCode === 301 || statusCode === 302) && this._requestOptions.method === \"POST\" || statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._requestOptions.method)) {\n        this._requestOptions.method = \"GET\";\n        this._requestBodyBuffers = [];\n      }\n      let previousHostName = this._removeMatchingHeaders(/^host$/i);\n      if (!previousHostName) {\n        previousHostName = new URL(this.currentURL).hostname;\n      }\n      const previousURL = this.currentURL;\n      if (!resendWithAuth) {\n        const nextURL = redirectAddress.startsWith(\"https:\") ? new URL(redirectAddress) : new URL(redirectAddress, this.currentURL);\n        if (nextURL.hostname !== previousHostName) {\n          this._removeMatchingHeaders(/^authorization$/i);\n        }\n        this.currentURL = nextURL.toString();\n      }\n      this.headers.Referer = previousURL;\n      this.emit(\"redirect\", response, this.headers, this.currentURL);\n      try {\n        this._performRequest();\n      } catch (cause) {\n        this.emit(\"error\", cause);\n      }\n    } else {\n      let pipeline = response;\n      const acceptEncoding = this.headers[\"Accept-Encoding\"];\n      const requestCompressed = typeof acceptEncoding === \"string\" && (acceptEncoding.includes(\"gzip\") || acceptEncoding.includes(\"deflate\"));\n      if (requestCompressed && this._requestOptions.method !== \"HEAD\" && statusCode >= 200 && statusCode !== 204 && statusCode !== 304) {\n        // Browserify's zlib does not support zlib.constants.\n        const zlibOptions = {\n          flush: (zlib.constants ?? zlib).Z_SYNC_FLUSH,\n          finishFlush: (zlib.constants ?? zlib).Z_SYNC_FLUSH\n        };\n        const contentEncoding = (response.headers[\"content-encoding\"] || \"identity\").trim().toLowerCase();\n        if (contentEncoding === \"gzip\") {\n          pipeline = zlib.createGunzip(zlibOptions);\n          response.pipe(pipeline);\n        } else if (contentEncoding === \"deflate\") {\n          pipeline = zlib.createInflate(zlibOptions);\n          response.pipe(pipeline);\n        }\n      }\n      pipeline.removeAllListeners(\"error\");\n      this.emit(\"response\", response, this.currentURL);\n      pipeline.on(\"data\", bytes => this.emit(\"data\", bytes));\n      pipeline.once(\"end\", bytes => this.emit(\"end\", bytes));\n      pipeline.on(\"error\", catchResErrors);\n      pipeline.on(\"close\", () => this.emit(\"close\"));\n      this._requestBodyBuffers = [];\n    }\n  }\n  getHeader(key, value) {\n    if (this._currentRequest) {\n      return this._currentRequest.getHeader(key, value);\n    }\n    return null;\n  }\n  _removeMatchingHeaders(regex) {\n    let lastValue;\n    for (const header in this.headers) {\n      if (regex.test(header)) {\n        lastValue = this.headers[header];\n        delete this.headers[header];\n      }\n    }\n    return lastValue;\n  }\n};","map":{"version":3,"names":["http","require","https","Writable","zlib","ver","process","version","replace","split","majorNodeVersion","Number","parseInt","abortRequest","clientRequest","destroy","removeAllListeners","on","module","exports","Request","constructor","url","clientOptions","requestOptions","Object","assign","currentURL","_requestOptions","headers","_ended","_redirectCount","_requestBodyBuffers","_bufferIndex","_performRequest","abort","_currentRequest","emit","pipeRequest","form","pipe","write","data","encoding","length","push","end","setHeader","name","value","removeHeader","toJSON","method","uri","URL","_writeNext","error","buffer","writableEnded","bind","_this","urlOptions","scheme","protocol","agent","agents","substring","hostname","port","path","pathname","search","request","response","_processResponse","cookies","originalCookieHeader","getHeader","cookieJar","getCookieStringSync","event","_len","arguments","args","Array","_key","_isRedirect","isArray","forEach","cookie","setCookieSync","ignoreError","e","statusCode","location","catchResErrors","err","message","redirectAddress","resendWithAuth","followRedirects","test","user","auth","pass","redirectError","Error","code","previousHostName","_removeMatchingHeaders","previousURL","nextURL","startsWith","toString","Referer","cause","pipeline","acceptEncoding","requestCompressed","includes","zlibOptions","flush","constants","Z_SYNC_FLUSH","finishFlush","contentEncoding","trim","toLowerCase","createGunzip","createInflate","bytes","once","key","regex","lastValue","header"],"sources":["/Users/bernard/Downloads/my-app/node_modules/jsdom/lib/jsdom/living/helpers/http-request.js"],"sourcesContent":["\"use strict\";\nconst http = require(\"http\");\nconst https = require(\"https\");\nconst { Writable } = require(\"stream\");\nconst zlib = require(\"zlib\");\n\nconst ver = process.version.replace(\"v\", \"\").split(\".\");\nconst majorNodeVersion = Number.parseInt(ver[0]);\n\nfunction abortRequest(clientRequest) {\n  clientRequest.destroy();\n  clientRequest.removeAllListeners();\n  clientRequest.on(\"error\", () => {});\n}\n\nmodule.exports = class Request extends Writable {\n  constructor(url, clientOptions, requestOptions) {\n    super();\n    Object.assign(this, clientOptions);\n    this.currentURL = url;\n    this._requestOptions = requestOptions;\n    this.headers = requestOptions.headers;\n    this._ended = false;\n    this._redirectCount = 0;\n    this._requestBodyBuffers = [];\n    this._bufferIndex = 0;\n    this._performRequest();\n  }\n\n  abort() {\n    abortRequest(this._currentRequest);\n    this.emit(\"abort\");\n    this.removeAllListeners();\n  }\n\n  pipeRequest(form) {\n    form.pipe(this._currentRequest);\n  }\n\n  write(data, encoding) {\n    if (data.length > 0) {\n      this._requestBodyBuffers.push({ data, encoding });\n      this._currentRequest.write(data, encoding);\n    }\n  }\n\n  end() {\n    this.emit(\"request\", this._currentRequest);\n    this._ended = true;\n    this._currentRequest.end();\n  }\n\n  setHeader(name, value) {\n    this.headers[name] = value;\n    this._currentRequest.setHeader(name, value);\n  }\n\n  removeHeader(name) {\n    delete this.headers[name];\n    this._currentRequest.removeHeader(name);\n  }\n\n  // Without this method, the test send-redirect-infinite-sync will halt the test suite\n  // TODO: investigate this further and ideally remove\n  toJSON() {\n    const { method, headers } = this._requestOptions;\n    return { uri: new URL(this.currentURL), method, headers };\n  }\n\n  _writeNext(error) {\n    if (this._currentRequest) {\n      if (error) {\n        this.emit(\"error\", error);\n      } else if (this._bufferIndex < this._requestBodyBuffers.length) {\n        const buffer = this._requestBodyBuffers[this._bufferIndex++];\n        if (!this._currentRequest.writableEnded) {\n          this._currentRequest.write(\n            buffer.data,\n            buffer.encoding,\n            this._writeNext.bind(this)\n          );\n        }\n      } else if (this._ended) {\n        this._currentRequest.end();\n      }\n    }\n  }\n\n  _performRequest() {\n    const urlOptions = new URL(this.currentURL);\n    const scheme = urlOptions.protocol;\n\n    // browserify's (http|https).request() does not work correctly with the (url, options, callback) signature. Instead\n    // we need to have options for each of the URL components. Note that we can't use the spread operator because URL\n    // instances don't have own properties for the URL components.\n    const requestOptions = {\n      ...this._requestOptions,\n      agent: this.agents[scheme.substring(0, scheme.length - 1)],\n      protocol: urlOptions.protocol,\n      hostname: urlOptions.hostname,\n      port: urlOptions.port,\n      path: urlOptions.pathname + urlOptions.search\n    };\n\n    const { request } = scheme === \"https:\" ? https : http;\n    this._currentRequest = request(requestOptions, response => {\n      this._processResponse(response);\n    });\n\n    let cookies;\n    if (this._redirectCount === 0) {\n      this.originalCookieHeader = this.getHeader(\"Cookie\");\n    }\n    if (this.cookieJar) {\n      cookies = this.cookieJar.getCookieStringSync(this.currentURL);\n    }\n    if (cookies && cookies.length) {\n      if (this.originalCookieHeader) {\n        this.setHeader(\"Cookie\", this.originalCookieHeader + \"; \" + cookies);\n      } else {\n        this.setHeader(\"Cookie\", cookies);\n      }\n    }\n\n    for (const event of [\"connect\", \"error\", \"socket\", \"timeout\"]) {\n      this._currentRequest.on(event, (...args) => {\n        this.emit(event, ...args);\n      });\n    }\n    if (this._isRedirect) {\n      this._bufferIndex = 0;\n      this._writeNext();\n    }\n  }\n\n  _processResponse(response) {\n    const cookies = response.headers[\"set-cookie\"];\n    if (this.cookieJar && Array.isArray(cookies)) {\n      try {\n        cookies.forEach(cookie => {\n          this.cookieJar.setCookieSync(cookie, this.currentURL, { ignoreError: true });\n        });\n      } catch (e) {\n        this.emit(\"error\", e);\n      }\n    }\n\n    const { statusCode } = response;\n    const { location } = response.headers;\n    // In Node v15, aborting a message with remaining data causes an error to be thrown,\n    // hence the version check\n    const catchResErrors = err => {\n      if (!(majorNodeVersion >= 15 && err.message === \"aborted\")) {\n        this.emit(\"error\", err);\n      }\n    };\n    response.on(\"error\", catchResErrors);\n    let redirectAddress = null;\n    let resendWithAuth = false;\n    if (typeof location === \"string\" &&\n      location.length &&\n      this.followRedirects &&\n      statusCode >= 300 &&\n      statusCode < 400) {\n      redirectAddress = location;\n    } else if (statusCode === 401 &&\n      /^Basic /i.test(response.headers[\"www-authenticate\"] || \"\") &&\n      (this.user && this.user.length)) {\n      this._requestOptions.auth = `${this.user}:${this.pass}`;\n      resendWithAuth = true;\n    }\n    if (redirectAddress || resendWithAuth) {\n      if (++this._redirectCount > 21) {\n        const redirectError = new Error(\"Maximum number of redirects exceeded\");\n        redirectError.code = \"ERR_TOO_MANY_REDIRECTS\";\n        this.emit(\"error\", redirectError);\n        return;\n      }\n      abortRequest(this._currentRequest);\n      response.destroy();\n      this._isRedirect = true;\n      if (((statusCode === 301 || statusCode === 302) && this._requestOptions.method === \"POST\") ||\n        (statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._requestOptions.method))) {\n        this._requestOptions.method = \"GET\";\n        this._requestBodyBuffers = [];\n      }\n      let previousHostName = this._removeMatchingHeaders(/^host$/i);\n      if (!previousHostName) {\n        previousHostName = new URL(this.currentURL).hostname;\n      }\n      const previousURL = this.currentURL;\n      if (!resendWithAuth) {\n        const nextURL = redirectAddress.startsWith(\"https:\") ?\n          new URL(redirectAddress) :\n          new URL(redirectAddress, this.currentURL);\n        if (nextURL.hostname !== previousHostName) {\n          this._removeMatchingHeaders(/^authorization$/i);\n        }\n        this.currentURL = nextURL.toString();\n      }\n      this.headers.Referer = previousURL;\n      this.emit(\"redirect\", response, this.headers, this.currentURL);\n      try {\n        this._performRequest();\n      } catch (cause) {\n        this.emit(\"error\", cause);\n      }\n    } else {\n      let pipeline = response;\n      const acceptEncoding = this.headers[\"Accept-Encoding\"];\n      const requestCompressed = typeof acceptEncoding === \"string\" &&\n        (acceptEncoding.includes(\"gzip\") || acceptEncoding.includes(\"deflate\"));\n      if (\n        requestCompressed &&\n        this._requestOptions.method !== \"HEAD\" &&\n        statusCode >= 200 &&\n        statusCode !== 204 &&\n        statusCode !== 304\n      ) {\n        // Browserify's zlib does not support zlib.constants.\n        const zlibOptions = {\n          flush: (zlib.constants ?? zlib).Z_SYNC_FLUSH,\n          finishFlush: (zlib.constants ?? zlib).Z_SYNC_FLUSH\n        };\n        const contentEncoding = (response.headers[\"content-encoding\"] || \"identity\").trim().toLowerCase();\n        if (contentEncoding === \"gzip\") {\n          pipeline = zlib.createGunzip(zlibOptions);\n          response.pipe(pipeline);\n        } else if (contentEncoding === \"deflate\") {\n          pipeline = zlib.createInflate(zlibOptions);\n          response.pipe(pipeline);\n        }\n      }\n      pipeline.removeAllListeners(\"error\");\n      this.emit(\"response\", response, this.currentURL);\n      pipeline.on(\"data\", bytes => this.emit(\"data\", bytes));\n      pipeline.once(\"end\", bytes => this.emit(\"end\", bytes));\n      pipeline.on(\"error\", catchResErrors);\n      pipeline.on(\"close\", () => this.emit(\"close\"));\n      this._requestBodyBuffers = [];\n    }\n  }\n\n  getHeader(key, value) {\n    if (this._currentRequest) {\n      return this._currentRequest.getHeader(key, value);\n    }\n    return null;\n  }\n\n  _removeMatchingHeaders(regex) {\n    let lastValue;\n    for (const header in this.headers) {\n      if (regex.test(header)) {\n        lastValue = this.headers[header];\n        delete this.headers[header];\n      }\n    }\n    return lastValue;\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}