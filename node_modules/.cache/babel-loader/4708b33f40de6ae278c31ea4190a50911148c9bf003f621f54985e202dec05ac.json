{"ast":null,"code":"\"use strict\";\n\nconst parse5 = require(\"parse5\");\nconst {\n  createElement\n} = require(\"../../living/helpers/create-element\");\nconst {\n  HTML_NS\n} = require(\"../../living/helpers/namespaces\");\nconst DocumentType = require(\"../../living/generated/DocumentType\");\nconst DocumentFragment = require(\"../../living/generated/DocumentFragment\");\nconst Text = require(\"../../living/generated/Text\");\nconst Comment = require(\"../../living/generated/Comment\");\nconst attributes = require(\"../../living/attributes\");\nconst nodeTypes = require(\"../../living/node-type\");\nconst serializationAdapter = require(\"../../living/domparsing/parse5-adapter-serialization\");\nconst {\n  customElementReactionsStack,\n  invokeCEReactions,\n  lookupCEDefinition\n} = require(\"../../living/helpers/custom-elements\");\nclass JSDOMParse5Adapter {\n  constructor(documentImpl) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this._documentImpl = documentImpl;\n    this._globalObject = documentImpl._globalObject;\n    this._fragment = options.fragment || false;\n\n    // Since the createElement hook doesn't provide the parent element, we keep track of this using _currentElement:\n    // https://github.com/inikulin/parse5/issues/285.\n    this._currentElement = undefined;\n  }\n  _ownerDocument() {\n    const {\n      _currentElement\n    } = this;\n\n    // The _currentElement is undefined when parsing elements at the root of the document.\n    if (_currentElement) {\n      return _currentElement.localName === \"template\" && _currentElement.namespaceURI === HTML_NS ? _currentElement.content._ownerDocument : _currentElement._ownerDocument;\n    }\n    return this._documentImpl;\n  }\n  createDocument() {\n    // parse5's model assumes that parse(html) will call into here to create the new Document, then return it. However,\n    // jsdom's model assumes we can create a Window (and through that create an empty Document), do some other setup\n    // stuff, and then parse, stuffing nodes into that Document as we go. So to adapt between these two models, we just\n    // return the already-created Document when asked by parse5 to \"create\" a Document.\n    return this._documentImpl;\n  }\n  createDocumentFragment() {\n    const ownerDocument = this._ownerDocument();\n    return DocumentFragment.createImpl(this._globalObject, [], {\n      ownerDocument\n    });\n  }\n\n  // https://html.spec.whatwg.org/#create-an-element-for-the-token\n  createElement(localName, namespace, attrs) {\n    const ownerDocument = this._ownerDocument();\n    const isAttribute = attrs.find(attr => attr.name === \"is\");\n    const isValue = isAttribute ? isAttribute.value : null;\n    const definition = lookupCEDefinition(ownerDocument, namespace, localName);\n    let willExecuteScript = false;\n    if (definition !== null && !this._fragment) {\n      willExecuteScript = true;\n    }\n    if (willExecuteScript) {\n      ownerDocument._throwOnDynamicMarkupInsertionCounter++;\n      customElementReactionsStack.push([]);\n    }\n    const element = createElement(ownerDocument, localName, namespace, null, isValue, willExecuteScript);\n    this.adoptAttributes(element, attrs);\n    if (willExecuteScript) {\n      const queue = customElementReactionsStack.pop();\n      invokeCEReactions(queue);\n      ownerDocument._throwOnDynamicMarkupInsertionCounter--;\n    }\n    if (\"_parserInserted\" in element) {\n      element._parserInserted = true;\n    }\n    return element;\n  }\n  createCommentNode(data) {\n    const ownerDocument = this._ownerDocument();\n    return Comment.createImpl(this._globalObject, [], {\n      data,\n      ownerDocument\n    });\n  }\n  appendChild(parentNode, newNode) {\n    parentNode._append(newNode);\n  }\n  insertBefore(parentNode, newNode, referenceNode) {\n    parentNode._insert(newNode, referenceNode);\n  }\n  setTemplateContent(templateElement, contentFragment) {\n    // This code makes the glue between jsdom and parse5 HTMLTemplateElement parsing:\n    //\n    // * jsdom during the construction of the HTMLTemplateElement (for example when create via\n    //   `document.createElement(\"template\")`), creates a DocumentFragment and set it into _templateContents.\n    // * parse5 when parsing a <template> tag creates an HTMLTemplateElement (`createElement` adapter hook) and also\n    //   create a DocumentFragment (`createDocumentFragment` adapter hook).\n    //\n    // At this point we now have to replace the one created in jsdom with one created by parse5.\n    const {\n      _ownerDocument,\n      _host\n    } = templateElement._templateContents;\n    contentFragment._ownerDocument = _ownerDocument;\n    contentFragment._host = _host;\n    templateElement._templateContents = contentFragment;\n  }\n  setDocumentType(document, name, publicId, systemId) {\n    const ownerDocument = this._ownerDocument();\n    const documentType = DocumentType.createImpl(this._globalObject, [], {\n      name,\n      publicId,\n      systemId,\n      ownerDocument\n    });\n    document._append(documentType);\n  }\n  setDocumentMode(document, mode) {\n    // TODO: the rest of jsdom ignores this\n    document._mode = mode;\n  }\n  detachNode(node) {\n    node.remove();\n  }\n  insertText(parentNode, text) {\n    const {\n      lastChild\n    } = parentNode;\n    if (lastChild && lastChild.nodeType === nodeTypes.TEXT_NODE) {\n      lastChild.data += text;\n    } else {\n      const ownerDocument = this._ownerDocument();\n      const textNode = Text.createImpl(this._globalObject, [], {\n        data: text,\n        ownerDocument\n      });\n      parentNode._append(textNode);\n    }\n  }\n  insertTextBefore(parentNode, text, referenceNode) {\n    const {\n      previousSibling\n    } = referenceNode;\n    if (previousSibling && previousSibling.nodeType === nodeTypes.TEXT_NODE) {\n      previousSibling.data += text;\n    } else {\n      const ownerDocument = this._ownerDocument();\n      const textNode = Text.createImpl(this._globalObject, [], {\n        data: text,\n        ownerDocument\n      });\n      parentNode._append(textNode, referenceNode);\n    }\n  }\n  adoptAttributes(element, attrs) {\n    for (const attr of attrs) {\n      const prefix = attr.prefix === \"\" ? null : attr.prefix;\n      attributes.setAttributeValue(element, attr.name, attr.value, prefix, attr.namespace);\n    }\n  }\n  onItemPush(after) {\n    this._currentElement = after;\n    after._pushedOnStackOfOpenElements?.();\n  }\n  onItemPop(before, newTop) {\n    this._currentElement = newTop;\n    before._poppedOffStackOfOpenElements?.();\n  }\n}\n\n// Assign shared adapters with serializer.\nObject.assign(JSDOMParse5Adapter.prototype, serializationAdapter);\nfunction parseFragment(markup, contextElement) {\n  const ownerDocument = contextElement.localName === \"template\" && contextElement.namespaceURI === HTML_NS ? contextElement.content._ownerDocument : contextElement._ownerDocument;\n  const config = {\n    ...ownerDocument._parseOptions,\n    sourceCodeLocationInfo: false,\n    treeAdapter: new JSDOMParse5Adapter(ownerDocument, {\n      fragment: true\n    })\n  };\n  return parse5.parseFragment(contextElement, markup, config);\n}\nfunction parseIntoDocument(markup, ownerDocument) {\n  const config = {\n    ...ownerDocument._parseOptions,\n    treeAdapter: new JSDOMParse5Adapter(ownerDocument)\n  };\n  return parse5.parse(markup, config);\n}\nmodule.exports = {\n  parseFragment,\n  parseIntoDocument\n};","map":{"version":3,"names":["parse5","require","createElement","HTML_NS","DocumentType","DocumentFragment","Text","Comment","attributes","nodeTypes","serializationAdapter","customElementReactionsStack","invokeCEReactions","lookupCEDefinition","JSDOMParse5Adapter","constructor","documentImpl","options","arguments","length","undefined","_documentImpl","_globalObject","_fragment","fragment","_currentElement","_ownerDocument","localName","namespaceURI","content","createDocument","createDocumentFragment","ownerDocument","createImpl","namespace","attrs","isAttribute","find","attr","name","isValue","value","definition","willExecuteScript","_throwOnDynamicMarkupInsertionCounter","push","element","adoptAttributes","queue","pop","_parserInserted","createCommentNode","data","appendChild","parentNode","newNode","_append","insertBefore","referenceNode","_insert","setTemplateContent","templateElement","contentFragment","_host","_templateContents","setDocumentType","document","publicId","systemId","documentType","setDocumentMode","mode","_mode","detachNode","node","remove","insertText","text","lastChild","nodeType","TEXT_NODE","textNode","insertTextBefore","previousSibling","prefix","setAttributeValue","onItemPush","after","_pushedOnStackOfOpenElements","onItemPop","before","newTop","_poppedOffStackOfOpenElements","Object","assign","prototype","parseFragment","markup","contextElement","config","_parseOptions","sourceCodeLocationInfo","treeAdapter","parseIntoDocument","parse","module","exports"],"sources":["/Users/bernard/Downloads/my-app/node_modules/jsdom/lib/jsdom/browser/parser/html.js"],"sourcesContent":["\"use strict\";\n\nconst parse5 = require(\"parse5\");\n\nconst { createElement } = require(\"../../living/helpers/create-element\");\nconst { HTML_NS } = require(\"../../living/helpers/namespaces\");\n\nconst DocumentType = require(\"../../living/generated/DocumentType\");\nconst DocumentFragment = require(\"../../living/generated/DocumentFragment\");\nconst Text = require(\"../../living/generated/Text\");\nconst Comment = require(\"../../living/generated/Comment\");\n\nconst attributes = require(\"../../living/attributes\");\nconst nodeTypes = require(\"../../living/node-type\");\n\nconst serializationAdapter = require(\"../../living/domparsing/parse5-adapter-serialization\");\nconst {\n  customElementReactionsStack, invokeCEReactions, lookupCEDefinition\n} = require(\"../../living/helpers/custom-elements\");\n\n\nclass JSDOMParse5Adapter {\n  constructor(documentImpl, options = {}) {\n    this._documentImpl = documentImpl;\n    this._globalObject = documentImpl._globalObject;\n    this._fragment = options.fragment || false;\n\n    // Since the createElement hook doesn't provide the parent element, we keep track of this using _currentElement:\n    // https://github.com/inikulin/parse5/issues/285.\n    this._currentElement = undefined;\n  }\n\n  _ownerDocument() {\n    const { _currentElement } = this;\n\n    // The _currentElement is undefined when parsing elements at the root of the document.\n    if (_currentElement) {\n      return _currentElement.localName === \"template\" && _currentElement.namespaceURI === HTML_NS ?\n        _currentElement.content._ownerDocument :\n        _currentElement._ownerDocument;\n    }\n\n    return this._documentImpl;\n  }\n\n  createDocument() {\n    // parse5's model assumes that parse(html) will call into here to create the new Document, then return it. However,\n    // jsdom's model assumes we can create a Window (and through that create an empty Document), do some other setup\n    // stuff, and then parse, stuffing nodes into that Document as we go. So to adapt between these two models, we just\n    // return the already-created Document when asked by parse5 to \"create\" a Document.\n    return this._documentImpl;\n  }\n\n  createDocumentFragment() {\n    const ownerDocument = this._ownerDocument();\n    return DocumentFragment.createImpl(this._globalObject, [], { ownerDocument });\n  }\n\n  // https://html.spec.whatwg.org/#create-an-element-for-the-token\n  createElement(localName, namespace, attrs) {\n    const ownerDocument = this._ownerDocument();\n\n    const isAttribute = attrs.find(attr => attr.name === \"is\");\n    const isValue = isAttribute ? isAttribute.value : null;\n\n    const definition = lookupCEDefinition(ownerDocument, namespace, localName);\n\n    let willExecuteScript = false;\n    if (definition !== null && !this._fragment) {\n      willExecuteScript = true;\n    }\n\n    if (willExecuteScript) {\n      ownerDocument._throwOnDynamicMarkupInsertionCounter++;\n      customElementReactionsStack.push([]);\n    }\n\n    const element = createElement(ownerDocument, localName, namespace, null, isValue, willExecuteScript);\n    this.adoptAttributes(element, attrs);\n\n    if (willExecuteScript) {\n      const queue = customElementReactionsStack.pop();\n      invokeCEReactions(queue);\n      ownerDocument._throwOnDynamicMarkupInsertionCounter--;\n    }\n\n    if (\"_parserInserted\" in element) {\n      element._parserInserted = true;\n    }\n\n    return element;\n  }\n\n  createCommentNode(data) {\n    const ownerDocument = this._ownerDocument();\n    return Comment.createImpl(this._globalObject, [], { data, ownerDocument });\n  }\n\n  appendChild(parentNode, newNode) {\n    parentNode._append(newNode);\n  }\n\n  insertBefore(parentNode, newNode, referenceNode) {\n    parentNode._insert(newNode, referenceNode);\n  }\n\n  setTemplateContent(templateElement, contentFragment) {\n    // This code makes the glue between jsdom and parse5 HTMLTemplateElement parsing:\n    //\n    // * jsdom during the construction of the HTMLTemplateElement (for example when create via\n    //   `document.createElement(\"template\")`), creates a DocumentFragment and set it into _templateContents.\n    // * parse5 when parsing a <template> tag creates an HTMLTemplateElement (`createElement` adapter hook) and also\n    //   create a DocumentFragment (`createDocumentFragment` adapter hook).\n    //\n    // At this point we now have to replace the one created in jsdom with one created by parse5.\n    const { _ownerDocument, _host } = templateElement._templateContents;\n    contentFragment._ownerDocument = _ownerDocument;\n    contentFragment._host = _host;\n\n    templateElement._templateContents = contentFragment;\n  }\n\n  setDocumentType(document, name, publicId, systemId) {\n    const ownerDocument = this._ownerDocument();\n    const documentType = DocumentType.createImpl(this._globalObject, [], { name, publicId, systemId, ownerDocument });\n\n    document._append(documentType);\n  }\n\n  setDocumentMode(document, mode) {\n    // TODO: the rest of jsdom ignores this\n    document._mode = mode;\n  }\n\n  detachNode(node) {\n    node.remove();\n  }\n\n  insertText(parentNode, text) {\n    const { lastChild } = parentNode;\n    if (lastChild && lastChild.nodeType === nodeTypes.TEXT_NODE) {\n      lastChild.data += text;\n    } else {\n      const ownerDocument = this._ownerDocument();\n      const textNode = Text.createImpl(this._globalObject, [], { data: text, ownerDocument });\n      parentNode._append(textNode);\n    }\n  }\n\n  insertTextBefore(parentNode, text, referenceNode) {\n    const { previousSibling } = referenceNode;\n    if (previousSibling && previousSibling.nodeType === nodeTypes.TEXT_NODE) {\n      previousSibling.data += text;\n    } else {\n      const ownerDocument = this._ownerDocument();\n      const textNode = Text.createImpl(this._globalObject, [], { data: text, ownerDocument });\n      parentNode._append(textNode, referenceNode);\n    }\n  }\n\n  adoptAttributes(element, attrs) {\n    for (const attr of attrs) {\n      const prefix = attr.prefix === \"\" ? null : attr.prefix;\n      attributes.setAttributeValue(element, attr.name, attr.value, prefix, attr.namespace);\n    }\n  }\n\n  onItemPush(after) {\n    this._currentElement = after;\n    after._pushedOnStackOfOpenElements?.();\n  }\n\n  onItemPop(before, newTop) {\n    this._currentElement = newTop;\n    before._poppedOffStackOfOpenElements?.();\n  }\n}\n\n// Assign shared adapters with serializer.\nObject.assign(JSDOMParse5Adapter.prototype, serializationAdapter);\n\nfunction parseFragment(markup, contextElement) {\n  const ownerDocument = contextElement.localName === \"template\" && contextElement.namespaceURI === HTML_NS ?\n    contextElement.content._ownerDocument :\n    contextElement._ownerDocument;\n\n  const config = {\n    ...ownerDocument._parseOptions,\n    sourceCodeLocationInfo: false,\n    treeAdapter: new JSDOMParse5Adapter(ownerDocument, { fragment: true })\n  };\n\n  return parse5.parseFragment(contextElement, markup, config);\n}\n\nfunction parseIntoDocument(markup, ownerDocument) {\n  const config = {\n    ...ownerDocument._parseOptions,\n    treeAdapter: new JSDOMParse5Adapter(ownerDocument)\n  };\n\n  return parse5.parse(markup, config);\n}\n\nmodule.exports = {\n  parseFragment,\n  parseIntoDocument\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}