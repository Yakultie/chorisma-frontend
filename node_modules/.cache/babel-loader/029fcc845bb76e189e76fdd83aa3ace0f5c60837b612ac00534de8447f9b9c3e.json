{"ast":null,"code":"\"use strict\";\n\nconst DOMException = require(\"domexception/webidl2js-wrapper\");\nconst EventTargetImpl = require(\"../events/EventTarget-impl\").implementation;\nconst {\n  simultaneousIterators\n} = require(\"../../utils\");\nconst NODE_TYPE = require(\"../node-type\");\nconst NODE_DOCUMENT_POSITION = require(\"../node-document-position\");\nconst {\n  clone,\n  locateNamespacePrefix,\n  locateNamespace\n} = require(\"../node\");\nconst {\n  setAnExistingAttributeValue\n} = require(\"../attributes\");\nconst NodeList = require(\"../generated/NodeList\");\nconst {\n  nodeRoot,\n  nodeLength,\n  isInclusiveAncestor\n} = require(\"../helpers/node\");\nconst {\n  domSymbolTree\n} = require(\"../helpers/internal-constants\");\nconst {\n  documentBaseURLSerialized\n} = require(\"../helpers/document-base-url\");\nconst {\n  queueTreeMutationRecord\n} = require(\"../helpers/mutation-observers\");\nconst {\n  enqueueCECallbackReaction,\n  tryUpgradeElement\n} = require(\"../helpers/custom-elements\");\nconst {\n  isShadowRoot,\n  shadowIncludingRoot,\n  assignSlot,\n  assignSlotableForTree,\n  assignSlotable,\n  signalSlotChange,\n  isSlot,\n  shadowIncludingInclusiveDescendantsIterator,\n  shadowIncludingDescendantsIterator\n} = require(\"../helpers/shadow-dom\");\nconst {\n  invalidateStyleCache\n} = require(\"../helpers/style-rules\");\nfunction nodeEquals(a, b) {\n  if (a.nodeType !== b.nodeType) {\n    return false;\n  }\n  switch (a.nodeType) {\n    case NODE_TYPE.DOCUMENT_TYPE_NODE:\n      if (a.name !== b.name || a.publicId !== b.publicId || a.systemId !== b.systemId) {\n        return false;\n      }\n      break;\n    case NODE_TYPE.ELEMENT_NODE:\n      if (a._namespaceURI !== b._namespaceURI || a._prefix !== b._prefix || a._localName !== b._localName || a._attributes.length !== b._attributes.length) {\n        return false;\n      }\n      break;\n    case NODE_TYPE.ATTRIBUTE_NODE:\n      if (a._namespace !== b._namespace || a._localName !== b._localName || a._value !== b._value) {\n        return false;\n      }\n      break;\n    case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      if (a._target !== b._target || a._data !== b._data) {\n        return false;\n      }\n      break;\n    case NODE_TYPE.TEXT_NODE:\n    case NODE_TYPE.COMMENT_NODE:\n      if (a._data !== b._data) {\n        return false;\n      }\n      break;\n  }\n  if (a.nodeType === NODE_TYPE.ELEMENT_NODE && !attributeListsEqual(a, b)) {\n    return false;\n  }\n  for (const nodes of simultaneousIterators(domSymbolTree.childrenIterator(a), domSymbolTree.childrenIterator(b))) {\n    if (!nodes[0] || !nodes[1]) {\n      // mismatch in the amount of childNodes\n      return false;\n    }\n    if (!nodeEquals(nodes[0], nodes[1])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// Needed by https://dom.spec.whatwg.org/#concept-node-equals\nfunction attributeListsEqual(elementA, elementB) {\n  const listA = elementA._attributeList;\n  const listB = elementB._attributeList;\n  const lengthA = listA.length;\n  const lengthB = listB.length;\n  if (lengthA !== lengthB) {\n    return false;\n  }\n  for (let i = 0; i < lengthA; ++i) {\n    const attrA = listA[i];\n    if (!listB.some(attrB => nodeEquals(attrA, attrB))) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// https://dom.spec.whatwg.org/#concept-tree-host-including-inclusive-ancestor\nfunction isHostInclusiveAncestor(nodeImplA, nodeImplB) {\n  for (const ancestor of domSymbolTree.ancestorsIterator(nodeImplB)) {\n    if (ancestor === nodeImplA) {\n      return true;\n    }\n  }\n  const rootImplB = nodeRoot(nodeImplB);\n  if (rootImplB._host) {\n    return isHostInclusiveAncestor(nodeImplA, rootImplB._host);\n  }\n  return false;\n}\nclass NodeImpl extends EventTargetImpl {\n  constructor(globalObject, args, privateData) {\n    super(globalObject, args, privateData);\n    domSymbolTree.initialize(this);\n    this._ownerDocument = privateData.ownerDocument;\n    this._childNodesList = null;\n    this._childrenList = null;\n    this._version = 0;\n    this._memoizedQueries = {};\n    this._registeredObserverList = [];\n    this._referencedRanges = new Set();\n  }\n  _getTheParent() {\n    if (this._assignedSlot) {\n      return this._assignedSlot;\n    }\n    return domSymbolTree.parent(this);\n  }\n  get parentNode() {\n    return domSymbolTree.parent(this);\n  }\n  getRootNode(options) {\n    return options.composed ? shadowIncludingRoot(this) : nodeRoot(this);\n  }\n  get nodeName() {\n    switch (this.nodeType) {\n      case NODE_TYPE.ELEMENT_NODE:\n        return this.tagName;\n      case NODE_TYPE.ATTRIBUTE_NODE:\n        return this._qualifiedName;\n      case NODE_TYPE.TEXT_NODE:\n        return \"#text\";\n      case NODE_TYPE.CDATA_SECTION_NODE:\n        return \"#cdata-section\";\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n        return this.target;\n      case NODE_TYPE.COMMENT_NODE:\n        return \"#comment\";\n      case NODE_TYPE.DOCUMENT_NODE:\n        return \"#document\";\n      case NODE_TYPE.DOCUMENT_TYPE_NODE:\n        return this.name;\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n        return \"#document-fragment\";\n    }\n\n    // should never happen\n    return null;\n  }\n  get firstChild() {\n    return domSymbolTree.firstChild(this);\n  }\n\n  // https://dom.spec.whatwg.org/#connected\n  // https://dom.spec.whatwg.org/#dom-node-isconnected\n  get isConnected() {\n    const root = shadowIncludingRoot(this);\n    return root && root.nodeType === NODE_TYPE.DOCUMENT_NODE;\n  }\n  get ownerDocument() {\n    return this.nodeType === NODE_TYPE.DOCUMENT_NODE ? null : this._ownerDocument;\n  }\n  get lastChild() {\n    return domSymbolTree.lastChild(this);\n  }\n  get childNodes() {\n    if (!this._childNodesList) {\n      this._childNodesList = NodeList.createImpl(this._globalObject, [], {\n        element: this,\n        query: () => domSymbolTree.childrenToArray(this)\n      });\n    } else {\n      this._childNodesList._update();\n    }\n    return this._childNodesList;\n  }\n  get nextSibling() {\n    return domSymbolTree.nextSibling(this);\n  }\n  get previousSibling() {\n    return domSymbolTree.previousSibling(this);\n  }\n  _modified() {\n    this._version++;\n    for (const ancestor of domSymbolTree.ancestorsIterator(this)) {\n      ancestor._version++;\n    }\n    if (this._childrenList) {\n      this._childrenList._update();\n    }\n    if (this._childNodesList) {\n      this._childNodesList._update();\n    }\n    this._clearMemoizedQueries();\n    invalidateStyleCache(this);\n  }\n  _childTextContentChangeSteps() {\n    invalidateStyleCache(this);\n  }\n  _clearMemoizedQueries() {\n    this._memoizedQueries = {};\n    const myParent = domSymbolTree.parent(this);\n    if (myParent) {\n      myParent._clearMemoizedQueries();\n    }\n  }\n  _descendantRemoved(parent, child) {\n    const myParent = domSymbolTree.parent(this);\n    if (myParent) {\n      myParent._descendantRemoved(parent, child);\n    }\n  }\n  _descendantAdded(parent, child) {\n    const myParent = domSymbolTree.parent(this);\n    if (myParent) {\n      myParent._descendantAdded(parent, child);\n    }\n  }\n  _attach() {\n    this._attached = true;\n    for (const child of domSymbolTree.childrenIterator(this)) {\n      if (child._attach) {\n        child._attach();\n      }\n    }\n  }\n  _detach() {\n    this._attached = false;\n    if (this._ownerDocument && this._ownerDocument._lastFocusedElement === this) {\n      this._ownerDocument._lastFocusedElement = null;\n    }\n    for (const child of domSymbolTree.childrenIterator(this)) {\n      if (child._detach) {\n        child._detach();\n      }\n    }\n  }\n  hasChildNodes() {\n    return domSymbolTree.hasChildren(this);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-node-normalize\n  normalize() {\n    // It is important to use a treeToArray instead of a treeToIterator here, because the\n    // treeToIterator doesn't support tree mutation in the middle of the traversal.\n    for (const node of domSymbolTree.treeToArray(this)) {\n      const parentNode = domSymbolTree.parent(node);\n      if (parentNode === null || node.nodeType !== NODE_TYPE.TEXT_NODE) {\n        continue;\n      }\n      let length = nodeLength(node);\n      if (length === 0) {\n        parentNode._remove(node);\n        continue;\n      }\n      const continuousExclusiveTextNodes = [];\n      for (const currentNode of domSymbolTree.previousSiblingsIterator(node)) {\n        if (currentNode.nodeType !== NODE_TYPE.TEXT_NODE) {\n          break;\n        }\n        continuousExclusiveTextNodes.unshift(currentNode);\n      }\n      for (const currentNode of domSymbolTree.nextSiblingsIterator(node)) {\n        if (currentNode.nodeType !== NODE_TYPE.TEXT_NODE) {\n          break;\n        }\n        continuousExclusiveTextNodes.push(currentNode);\n      }\n      const data = continuousExclusiveTextNodes.reduce((d, n) => d + n._data, \"\");\n      node.replaceData(length, 0, data);\n      let currentNode = domSymbolTree.nextSibling(node);\n      while (currentNode && currentNode.nodeType === NODE_TYPE.TEXT_NODE) {\n        const currentNodeIndex = domSymbolTree.index(currentNode);\n        for (const range of node._referencedRanges) {\n          const {\n            _start,\n            _end\n          } = range;\n          if (_start.node === currentNode) {\n            range._setLiveRangeStart(node, _start.offset + length);\n          }\n          if (_end.node === currentNode) {\n            range._setLiveRangeEnd(node, _end.offset + length);\n          }\n        }\n        for (const range of parentNode._referencedRanges) {\n          const {\n            _start,\n            _end\n          } = range;\n          if (_start.node === parentNode && _start.offset === currentNodeIndex) {\n            range._setLiveRangeStart(node, length);\n          }\n          if (_end.node === parentNode && _end.offset === currentNodeIndex) {\n            range._setLiveRangeEnd(node, length);\n          }\n        }\n        length += nodeLength(currentNode);\n        currentNode = domSymbolTree.nextSibling(currentNode);\n      }\n      for (const continuousExclusiveTextNode of continuousExclusiveTextNodes) {\n        parentNode._remove(continuousExclusiveTextNode);\n      }\n    }\n  }\n  get parentElement() {\n    const parentNode = domSymbolTree.parent(this);\n    return parentNode !== null && parentNode.nodeType === NODE_TYPE.ELEMENT_NODE ? parentNode : null;\n  }\n  get baseURI() {\n    return documentBaseURLSerialized(this._ownerDocument);\n  }\n  compareDocumentPosition(other) {\n    // Let node1 be other and node2 be the context object.\n    let node1 = other;\n    let node2 = this;\n    let attr1 = null;\n    let attr2 = null;\n    if (node1.nodeType === NODE_TYPE.ATTRIBUTE_NODE) {\n      attr1 = node1;\n      node1 = attr1._element;\n    }\n    if (node2.nodeType === NODE_TYPE.ATTRIBUTE_NODE) {\n      attr2 = node2;\n      node2 = attr2._element;\n      if (attr1 !== null && node1 !== null && node2 === node1) {\n        for (const attr of node2._attributeList) {\n          if (nodeEquals(attr, attr1)) {\n            return NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_PRECEDING;\n          }\n          if (nodeEquals(attr, attr2)) {\n            return NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_FOLLOWING;\n          }\n        }\n      }\n    }\n    const result = domSymbolTree.compareTreePosition(node2, node1);\n\n    // “If other and reference are not in the same tree, return the result of adding DOCUMENT_POSITION_DISCONNECTED,\n    //  DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC, and either DOCUMENT_POSITION_PRECEDING or\n    // DOCUMENT_POSITION_FOLLOWING, with the constraint that this is to be consistent, together.”\n    if (result === NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_DISCONNECTED) {\n      // symbol-tree does not add these bits required by the spec:\n      return NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_DISCONNECTED | NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_FOLLOWING;\n    }\n    return result;\n  }\n  lookupPrefix(namespace) {\n    if (namespace === null || namespace === \"\") {\n      return null;\n    }\n    switch (this.nodeType) {\n      case NODE_TYPE.ELEMENT_NODE:\n        {\n          return locateNamespacePrefix(this, namespace);\n        }\n      case NODE_TYPE.DOCUMENT_NODE:\n        {\n          return this.documentElement !== null ? locateNamespacePrefix(this.documentElement, namespace) : null;\n        }\n      case NODE_TYPE.DOCUMENT_TYPE_NODE:\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n        {\n          return null;\n        }\n      case NODE_TYPE.ATTRIBUTE_NODE:\n        {\n          return this._element !== null ? locateNamespacePrefix(this._element, namespace) : null;\n        }\n      default:\n        {\n          return this.parentElement !== null ? locateNamespacePrefix(this.parentElement, namespace) : null;\n        }\n    }\n  }\n  lookupNamespaceURI(prefix) {\n    if (prefix === \"\") {\n      prefix = null;\n    }\n    return locateNamespace(this, prefix);\n  }\n  isDefaultNamespace(namespace) {\n    if (namespace === \"\") {\n      namespace = null;\n    }\n    const defaultNamespace = locateNamespace(this, null);\n    return defaultNamespace === namespace;\n  }\n  contains(other) {\n    return isInclusiveAncestor(this, other);\n  }\n  isEqualNode(node) {\n    if (node === null) {\n      return false;\n    }\n\n    // Fast-path, not in the spec\n    if (this === node) {\n      return true;\n    }\n    return nodeEquals(this, node);\n  }\n  isSameNode(node) {\n    if (this === node) {\n      return true;\n    }\n    return false;\n  }\n  cloneNode(deep) {\n    if (isShadowRoot(this)) {\n      throw DOMException.create(this._globalObject, [\"ShadowRoot nodes are not clonable.\", \"NotSupportedError\"]);\n    }\n    deep = Boolean(deep);\n    return clone(this, undefined, deep);\n  }\n  get nodeValue() {\n    switch (this.nodeType) {\n      case NODE_TYPE.ATTRIBUTE_NODE:\n        {\n          return this._value;\n        }\n      case NODE_TYPE.TEXT_NODE:\n      case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      case NODE_TYPE.COMMENT_NODE:\n        {\n          return this._data;\n        }\n      default:\n        {\n          return null;\n        }\n    }\n  }\n  set nodeValue(value) {\n    if (value === null) {\n      value = \"\";\n    }\n    switch (this.nodeType) {\n      case NODE_TYPE.ATTRIBUTE_NODE:\n        {\n          setAnExistingAttributeValue(this, value);\n          break;\n        }\n      case NODE_TYPE.TEXT_NODE:\n      case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      case NODE_TYPE.COMMENT_NODE:\n        {\n          this.replaceData(0, this.length, value);\n          break;\n        }\n    }\n  }\n\n  // https://dom.spec.whatwg.org/#dom-node-textcontent\n  get textContent() {\n    switch (this.nodeType) {\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n      case NODE_TYPE.ELEMENT_NODE:\n        {\n          let text = \"\";\n          for (const child of domSymbolTree.treeIterator(this)) {\n            if (child.nodeType === NODE_TYPE.TEXT_NODE || child.nodeType === NODE_TYPE.CDATA_SECTION_NODE) {\n              text += child.nodeValue;\n            }\n          }\n          return text;\n        }\n      case NODE_TYPE.ATTRIBUTE_NODE:\n        {\n          return this._value;\n        }\n      case NODE_TYPE.TEXT_NODE:\n      case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      case NODE_TYPE.COMMENT_NODE:\n        {\n          return this._data;\n        }\n      default:\n        {\n          return null;\n        }\n    }\n  }\n  set textContent(value) {\n    if (value === null) {\n      value = \"\";\n    }\n    switch (this.nodeType) {\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n      case NODE_TYPE.ELEMENT_NODE:\n        {\n          // https://dom.spec.whatwg.org/#string-replace-all\n          let nodeImpl = null;\n          if (value !== \"\") {\n            nodeImpl = this._ownerDocument.createTextNode(value);\n          }\n          this._replaceAll(nodeImpl);\n          break;\n        }\n      case NODE_TYPE.ATTRIBUTE_NODE:\n        {\n          setAnExistingAttributeValue(this, value);\n          break;\n        }\n      case NODE_TYPE.TEXT_NODE:\n      case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      case NODE_TYPE.COMMENT_NODE:\n        {\n          this.replaceData(0, this.length, value);\n          break;\n        }\n    }\n  }\n\n  // https://dom.spec.whatwg.org/#dom-node-insertbefore\n  insertBefore(nodeImpl, childImpl) {\n    return this._preInsert(nodeImpl, childImpl);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-node-appendchild\n  appendChild(nodeImpl) {\n    return this._append(nodeImpl);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-node-replacechild\n  replaceChild(nodeImpl, childImpl) {\n    return this._replace(nodeImpl, childImpl);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-node-removechild\n  removeChild(oldChildImpl) {\n    return this._preRemove(oldChildImpl);\n  }\n\n  // https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity\n  _preInsertValidity(nodeImpl, childImpl) {\n    const {\n      nodeType,\n      nodeName\n    } = nodeImpl;\n    const {\n      nodeType: parentType,\n      nodeName: parentName\n    } = this;\n    if (parentType !== NODE_TYPE.DOCUMENT_NODE && parentType !== NODE_TYPE.DOCUMENT_FRAGMENT_NODE && parentType !== NODE_TYPE.ELEMENT_NODE) {\n      throw DOMException.create(this._globalObject, [`Node can't be inserted in a ${parentName} parent.`, \"HierarchyRequestError\"]);\n    }\n    if (isHostInclusiveAncestor(nodeImpl, this)) {\n      throw DOMException.create(this._globalObject, [\"The operation would yield an incorrect node tree.\", \"HierarchyRequestError\"]);\n    }\n    if (childImpl && domSymbolTree.parent(childImpl) !== this) {\n      throw DOMException.create(this._globalObject, [\"The child can not be found in the parent.\", \"NotFoundError\"]);\n    }\n    if (nodeType !== NODE_TYPE.DOCUMENT_FRAGMENT_NODE && nodeType !== NODE_TYPE.DOCUMENT_TYPE_NODE && nodeType !== NODE_TYPE.ELEMENT_NODE && nodeType !== NODE_TYPE.TEXT_NODE && nodeType !== NODE_TYPE.CDATA_SECTION_NODE &&\n    // CData section extends from Text\n    nodeType !== NODE_TYPE.PROCESSING_INSTRUCTION_NODE && nodeType !== NODE_TYPE.COMMENT_NODE) {\n      throw DOMException.create(this._globalObject, [`${nodeName} node can't be inserted in parent node.`, \"HierarchyRequestError\"]);\n    }\n    if (nodeType === NODE_TYPE.TEXT_NODE && parentType === NODE_TYPE.DOCUMENT_NODE || nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE && parentType !== NODE_TYPE.DOCUMENT_NODE) {\n      throw DOMException.create(this._globalObject, [`${nodeName} node can't be inserted in ${parentName} parent.`, \"HierarchyRequestError\"]);\n    }\n    if (parentType === NODE_TYPE.DOCUMENT_NODE) {\n      const nodeChildren = domSymbolTree.childrenToArray(nodeImpl);\n      const parentChildren = domSymbolTree.childrenToArray(this);\n      switch (nodeType) {\n        case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n          {\n            const nodeChildrenElements = nodeChildren.filter(child => child.nodeType === NODE_TYPE.ELEMENT_NODE);\n            if (nodeChildrenElements.length > 1) {\n              throw DOMException.create(this._globalObject, [`Invalid insertion of ${nodeName} node in ${parentName} node.`, \"HierarchyRequestError\"]);\n            }\n            const hasNodeTextChildren = nodeChildren.some(child => child.nodeType === NODE_TYPE.TEXT_NODE);\n            if (hasNodeTextChildren) {\n              throw DOMException.create(this._globalObject, [`Invalid insertion of ${nodeName} node in ${parentName} node.`, \"HierarchyRequestError\"]);\n            }\n            if (nodeChildrenElements.length === 1 && (parentChildren.some(child => child.nodeType === NODE_TYPE.ELEMENT_NODE) || childImpl && childImpl.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE || childImpl && domSymbolTree.nextSibling(childImpl) && domSymbolTree.nextSibling(childImpl).nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE)) {\n              throw DOMException.create(this._globalObject, [`Invalid insertion of ${nodeName} node in ${parentName} node.`, \"HierarchyRequestError\"]);\n            }\n            break;\n          }\n        case NODE_TYPE.ELEMENT_NODE:\n          if (parentChildren.some(child => child.nodeType === NODE_TYPE.ELEMENT_NODE) || childImpl && childImpl.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE || childImpl && domSymbolTree.nextSibling(childImpl) && domSymbolTree.nextSibling(childImpl).nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) {\n            throw DOMException.create(this._globalObject, [`Invalid insertion of ${nodeName} node in ${parentName} node.`, \"HierarchyRequestError\"]);\n          }\n          break;\n        case NODE_TYPE.DOCUMENT_TYPE_NODE:\n          if (parentChildren.some(child => child.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) || childImpl && domSymbolTree.previousSibling(childImpl) && domSymbolTree.previousSibling(childImpl).nodeType === NODE_TYPE.ELEMENT_NODE || !childImpl && parentChildren.some(child => child.nodeType === NODE_TYPE.ELEMENT_NODE)) {\n            throw DOMException.create(this._globalObject, [`Invalid insertion of ${nodeName} node in ${parentName} node.`, \"HierarchyRequestError\"]);\n          }\n          break;\n      }\n    }\n  }\n\n  // https://dom.spec.whatwg.org/#concept-node-pre-insert\n  _preInsert(nodeImpl, childImpl) {\n    this._preInsertValidity(nodeImpl, childImpl);\n    let referenceChildImpl = childImpl;\n    if (referenceChildImpl === nodeImpl) {\n      referenceChildImpl = domSymbolTree.nextSibling(nodeImpl);\n    }\n    this._ownerDocument._adoptNode(nodeImpl);\n    this._insert(nodeImpl, referenceChildImpl);\n    return nodeImpl;\n  }\n\n  // https://dom.spec.whatwg.org/#concept-node-insert\n  _insert(nodeImpl, childImpl, suppressObservers) {\n    const count = nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE ? domSymbolTree.childrenCount(nodeImpl) : 1;\n    if (childImpl) {\n      const childIndex = domSymbolTree.index(childImpl);\n      for (const range of this._referencedRanges) {\n        const {\n          _start,\n          _end\n        } = range;\n        if (_start.offset > childIndex) {\n          range._setLiveRangeStart(this, _start.offset + count);\n        }\n        if (_end.offset > childIndex) {\n          range._setLiveRangeEnd(this, _end.offset + count);\n        }\n      }\n    }\n    const nodesImpl = nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE ? domSymbolTree.childrenToArray(nodeImpl) : [nodeImpl];\n    if (nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE) {\n      let grandChildImpl;\n      while (grandChildImpl = domSymbolTree.firstChild(nodeImpl)) {\n        nodeImpl._remove(grandChildImpl, true);\n      }\n    }\n    if (nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE) {\n      queueTreeMutationRecord(nodeImpl, [], nodesImpl, null, null);\n    }\n    const previousChildImpl = childImpl ? domSymbolTree.previousSibling(childImpl) : domSymbolTree.lastChild(this);\n    let isConnected;\n    for (const node of nodesImpl) {\n      if (!childImpl) {\n        domSymbolTree.appendChild(this, node);\n      } else {\n        domSymbolTree.insertBefore(childImpl, node);\n      }\n      if (this.nodeType === NODE_TYPE.ELEMENT_NODE && this._shadowRoot !== null && (node.nodeType === NODE_TYPE.ELEMENT_NODE || node.nodeType === NODE_TYPE.TEXT_NODE)) {\n        assignSlot(node);\n      }\n      this._modified();\n      if (node.nodeType === NODE_TYPE.TEXT_NODE || node.nodeType === NODE_TYPE.CDATA_SECTION_NODE) {\n        this._childTextContentChangeSteps();\n      }\n      if (isSlot(this) && this._assignedNodes.length === 0 && isShadowRoot(nodeRoot(this))) {\n        signalSlotChange(this);\n      }\n      const root = nodeRoot(node);\n      if (isShadowRoot(root)) {\n        assignSlotableForTree(root);\n      }\n      if (this._attached && nodeImpl._attach) {\n        node._attach();\n      }\n      this._descendantAdded(this, node);\n      if (isConnected === undefined) {\n        isConnected = node.isConnected;\n      }\n      if (isConnected) {\n        for (const inclusiveDescendant of shadowIncludingInclusiveDescendantsIterator(node)) {\n          if (inclusiveDescendant._ceState === \"custom\") {\n            enqueueCECallbackReaction(inclusiveDescendant, \"connectedCallback\", []);\n          } else {\n            tryUpgradeElement(inclusiveDescendant);\n          }\n        }\n      }\n    }\n    if (!suppressObservers) {\n      queueTreeMutationRecord(this, nodesImpl, [], previousChildImpl, childImpl);\n    }\n  }\n\n  // https://dom.spec.whatwg.org/#concept-node-append\n  _append(nodeImpl) {\n    return this._preInsert(nodeImpl, null);\n  }\n\n  // https://dom.spec.whatwg.org/#concept-node-replace\n  _replace(nodeImpl, childImpl) {\n    const {\n      nodeType,\n      nodeName\n    } = nodeImpl;\n    const {\n      nodeType: parentType,\n      nodeName: parentName\n    } = this;\n\n    // Note: This section differs from the pre-insert validation algorithm.\n    if (parentType !== NODE_TYPE.DOCUMENT_NODE && parentType !== NODE_TYPE.DOCUMENT_FRAGMENT_NODE && parentType !== NODE_TYPE.ELEMENT_NODE) {\n      throw DOMException.create(this._globalObject, [`Node can't be inserted in a ${parentName} parent.`, \"HierarchyRequestError\"]);\n    }\n    if (isHostInclusiveAncestor(nodeImpl, this)) {\n      throw DOMException.create(this._globalObject, [\"The operation would yield an incorrect node tree.\", \"HierarchyRequestError\"]);\n    }\n    if (childImpl && domSymbolTree.parent(childImpl) !== this) {\n      throw DOMException.create(this._globalObject, [\"The child can not be found in the parent.\", \"NotFoundError\"]);\n    }\n    if (nodeType !== NODE_TYPE.DOCUMENT_FRAGMENT_NODE && nodeType !== NODE_TYPE.DOCUMENT_TYPE_NODE && nodeType !== NODE_TYPE.ELEMENT_NODE && nodeType !== NODE_TYPE.TEXT_NODE && nodeType !== NODE_TYPE.CDATA_SECTION_NODE &&\n    // CData section extends from Text\n    nodeType !== NODE_TYPE.PROCESSING_INSTRUCTION_NODE && nodeType !== NODE_TYPE.COMMENT_NODE) {\n      throw DOMException.create(this._globalObject, [`${nodeName} node can't be inserted in parent node.`, \"HierarchyRequestError\"]);\n    }\n    if (nodeType === NODE_TYPE.TEXT_NODE && parentType === NODE_TYPE.DOCUMENT_NODE || nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE && parentType !== NODE_TYPE.DOCUMENT_NODE) {\n      throw DOMException.create(this._globalObject, [`${nodeName} node can't be inserted in ${parentName} parent.`, \"HierarchyRequestError\"]);\n    }\n    if (parentType === NODE_TYPE.DOCUMENT_NODE) {\n      const nodeChildren = domSymbolTree.childrenToArray(nodeImpl);\n      const parentChildren = domSymbolTree.childrenToArray(this);\n      switch (nodeType) {\n        case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n          {\n            const nodeChildrenElements = nodeChildren.filter(child => child.nodeType === NODE_TYPE.ELEMENT_NODE);\n            if (nodeChildrenElements.length > 1) {\n              throw DOMException.create(this._globalObject, [`Invalid insertion of ${nodeName} node in ${parentName} node.`, \"HierarchyRequestError\"]);\n            }\n            const hasNodeTextChildren = nodeChildren.some(child => child.nodeType === NODE_TYPE.TEXT_NODE);\n            if (hasNodeTextChildren) {\n              throw DOMException.create(this._globalObject, [`Invalid insertion of ${nodeName} node in ${parentName} node.`, \"HierarchyRequestError\"]);\n            }\n            const parentChildElements = parentChildren.filter(child => child.nodeType === NODE_TYPE.ELEMENT_NODE);\n            if (nodeChildrenElements.length === 1 && (parentChildElements.length === 1 && parentChildElements[0] !== childImpl || childImpl && domSymbolTree.nextSibling(childImpl) && domSymbolTree.nextSibling(childImpl).nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE)) {\n              throw DOMException.create(this._globalObject, [`Invalid insertion of ${nodeName} node in ${parentName} node.`, \"HierarchyRequestError\"]);\n            }\n            break;\n          }\n        case NODE_TYPE.ELEMENT_NODE:\n          if (parentChildren.some(child => child.nodeType === NODE_TYPE.ELEMENT_NODE && child !== childImpl) || childImpl && domSymbolTree.nextSibling(childImpl) && domSymbolTree.nextSibling(childImpl).nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) {\n            throw DOMException.create(this._globalObject, [`Invalid insertion of ${nodeName} node in ${parentName} node.`, \"HierarchyRequestError\"]);\n          }\n          break;\n        case NODE_TYPE.DOCUMENT_TYPE_NODE:\n          if (parentChildren.some(child => child.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE && child !== childImpl) || childImpl && domSymbolTree.previousSibling(childImpl) && domSymbolTree.previousSibling(childImpl).nodeType === NODE_TYPE.ELEMENT_NODE) {\n            throw DOMException.create(this._globalObject, [`Invalid insertion of ${nodeName} node in ${parentName} node.`, \"HierarchyRequestError\"]);\n          }\n          break;\n      }\n    }\n    let referenceChildImpl = domSymbolTree.nextSibling(childImpl);\n    if (referenceChildImpl === nodeImpl) {\n      referenceChildImpl = domSymbolTree.nextSibling(nodeImpl);\n    }\n    const previousSiblingImpl = domSymbolTree.previousSibling(childImpl);\n    this._ownerDocument._adoptNode(nodeImpl);\n    let removedNodesImpl = [];\n    if (domSymbolTree.parent(childImpl)) {\n      removedNodesImpl = [childImpl];\n      this._remove(childImpl, true);\n    }\n    const nodesImpl = nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE ? domSymbolTree.childrenToArray(nodeImpl) : [nodeImpl];\n    this._insert(nodeImpl, referenceChildImpl, true);\n    queueTreeMutationRecord(this, nodesImpl, removedNodesImpl, previousSiblingImpl, referenceChildImpl);\n    return childImpl;\n  }\n\n  // https://dom.spec.whatwg.org/#concept-node-replace-all\n  _replaceAll(nodeImpl) {\n    if (nodeImpl !== null) {\n      this._ownerDocument._adoptNode(nodeImpl);\n    }\n    const removedNodesImpl = domSymbolTree.childrenToArray(this);\n    let addedNodesImpl;\n    if (nodeImpl === null) {\n      addedNodesImpl = [];\n    } else if (nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE) {\n      addedNodesImpl = domSymbolTree.childrenToArray(nodeImpl);\n    } else {\n      addedNodesImpl = [nodeImpl];\n    }\n    for (const childImpl of domSymbolTree.childrenIterator(this)) {\n      this._remove(childImpl, true);\n    }\n    if (nodeImpl !== null) {\n      this._insert(nodeImpl, null, true);\n    }\n    if (addedNodesImpl.length > 0 || removedNodesImpl.length > 0) {\n      queueTreeMutationRecord(this, addedNodesImpl, removedNodesImpl, null, null);\n    }\n  }\n\n  // https://dom.spec.whatwg.org/#concept-node-pre-remove\n  _preRemove(childImpl) {\n    if (domSymbolTree.parent(childImpl) !== this) {\n      throw DOMException.create(this._globalObject, [\"The node to be removed is not a child of this node.\", \"NotFoundError\"]);\n    }\n    this._remove(childImpl);\n    return childImpl;\n  }\n\n  // https://dom.spec.whatwg.org/#concept-node-remove\n  _remove(nodeImpl, suppressObservers) {\n    const index = domSymbolTree.index(nodeImpl);\n    for (const descendant of domSymbolTree.treeIterator(nodeImpl)) {\n      for (const range of descendant._referencedRanges) {\n        const {\n          _start,\n          _end\n        } = range;\n        if (_start.node === descendant) {\n          range._setLiveRangeStart(this, index);\n        }\n        if (_end.node === descendant) {\n          range._setLiveRangeEnd(this, index);\n        }\n      }\n    }\n    for (const range of this._referencedRanges) {\n      const {\n        _start,\n        _end\n      } = range;\n      if (_start.node === this && _start.offset > index) {\n        range._setLiveRangeStart(this, _start.offset - 1);\n      }\n      if (_end.node === this && _end.offset > index) {\n        range._setLiveRangeEnd(this, _end.offset - 1);\n      }\n    }\n    if (this._ownerDocument) {\n      this._ownerDocument._runPreRemovingSteps(nodeImpl);\n    }\n    const oldPreviousSiblingImpl = domSymbolTree.previousSibling(nodeImpl);\n    const oldNextSiblingImpl = domSymbolTree.nextSibling(nodeImpl);\n    domSymbolTree.remove(nodeImpl);\n    if (nodeImpl._assignedSlot) {\n      assignSlotable(nodeImpl._assignedSlot);\n    }\n    if (isSlot(this) && this._assignedNodes.length === 0 && isShadowRoot(nodeRoot(this))) {\n      signalSlotChange(this);\n    }\n    let hasSlotDescendant = isSlot(nodeImpl);\n    if (!hasSlotDescendant) {\n      for (const child of domSymbolTree.treeIterator(nodeImpl)) {\n        if (isSlot(child)) {\n          hasSlotDescendant = true;\n          break;\n        }\n      }\n    }\n    if (hasSlotDescendant) {\n      assignSlotableForTree(nodeRoot(this));\n      assignSlotableForTree(nodeImpl);\n    }\n    this._modified();\n    nodeImpl._detach();\n    this._descendantRemoved(this, nodeImpl);\n    if (this.isConnected) {\n      if (nodeImpl._ceState === \"custom\") {\n        enqueueCECallbackReaction(nodeImpl, \"disconnectedCallback\", []);\n      }\n      for (const descendantImpl of shadowIncludingDescendantsIterator(nodeImpl)) {\n        if (descendantImpl._ceState === \"custom\") {\n          enqueueCECallbackReaction(descendantImpl, \"disconnectedCallback\", []);\n        }\n      }\n    }\n    if (!suppressObservers) {\n      queueTreeMutationRecord(this, [], [nodeImpl], oldPreviousSiblingImpl, oldNextSiblingImpl);\n    }\n    if (nodeImpl.nodeType === NODE_TYPE.TEXT_NODE) {\n      this._childTextContentChangeSteps();\n    }\n  }\n}\nmodule.exports = {\n  implementation: NodeImpl\n};","map":{"version":3,"names":["DOMException","require","EventTargetImpl","implementation","simultaneousIterators","NODE_TYPE","NODE_DOCUMENT_POSITION","clone","locateNamespacePrefix","locateNamespace","setAnExistingAttributeValue","NodeList","nodeRoot","nodeLength","isInclusiveAncestor","domSymbolTree","documentBaseURLSerialized","queueTreeMutationRecord","enqueueCECallbackReaction","tryUpgradeElement","isShadowRoot","shadowIncludingRoot","assignSlot","assignSlotableForTree","assignSlotable","signalSlotChange","isSlot","shadowIncludingInclusiveDescendantsIterator","shadowIncludingDescendantsIterator","invalidateStyleCache","nodeEquals","a","b","nodeType","DOCUMENT_TYPE_NODE","name","publicId","systemId","ELEMENT_NODE","_namespaceURI","_prefix","_localName","_attributes","length","ATTRIBUTE_NODE","_namespace","_value","PROCESSING_INSTRUCTION_NODE","_target","_data","TEXT_NODE","COMMENT_NODE","attributeListsEqual","nodes","childrenIterator","elementA","elementB","listA","_attributeList","listB","lengthA","lengthB","i","attrA","some","attrB","isHostInclusiveAncestor","nodeImplA","nodeImplB","ancestor","ancestorsIterator","rootImplB","_host","NodeImpl","constructor","globalObject","args","privateData","initialize","_ownerDocument","ownerDocument","_childNodesList","_childrenList","_version","_memoizedQueries","_registeredObserverList","_referencedRanges","Set","_getTheParent","_assignedSlot","parent","parentNode","getRootNode","options","composed","nodeName","tagName","_qualifiedName","CDATA_SECTION_NODE","target","DOCUMENT_NODE","DOCUMENT_FRAGMENT_NODE","firstChild","isConnected","root","lastChild","childNodes","createImpl","_globalObject","element","query","childrenToArray","_update","nextSibling","previousSibling","_modified","_clearMemoizedQueries","_childTextContentChangeSteps","myParent","_descendantRemoved","child","_descendantAdded","_attach","_attached","_detach","_lastFocusedElement","hasChildNodes","hasChildren","normalize","node","treeToArray","_remove","continuousExclusiveTextNodes","currentNode","previousSiblingsIterator","unshift","nextSiblingsIterator","push","data","reduce","d","n","replaceData","currentNodeIndex","index","range","_start","_end","_setLiveRangeStart","offset","_setLiveRangeEnd","continuousExclusiveTextNode","parentElement","baseURI","compareDocumentPosition","other","node1","node2","attr1","attr2","_element","attr","DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC","DOCUMENT_POSITION_PRECEDING","DOCUMENT_POSITION_FOLLOWING","result","compareTreePosition","DOCUMENT_POSITION_DISCONNECTED","lookupPrefix","namespace","documentElement","lookupNamespaceURI","prefix","isDefaultNamespace","defaultNamespace","contains","isEqualNode","isSameNode","cloneNode","deep","create","Boolean","undefined","nodeValue","value","textContent","text","treeIterator","nodeImpl","createTextNode","_replaceAll","insertBefore","childImpl","_preInsert","appendChild","_append","replaceChild","_replace","removeChild","oldChildImpl","_preRemove","_preInsertValidity","parentType","parentName","nodeChildren","parentChildren","nodeChildrenElements","filter","hasNodeTextChildren","referenceChildImpl","_adoptNode","_insert","suppressObservers","count","childrenCount","childIndex","nodesImpl","grandChildImpl","previousChildImpl","_shadowRoot","_assignedNodes","inclusiveDescendant","_ceState","parentChildElements","previousSiblingImpl","removedNodesImpl","addedNodesImpl","descendant","_runPreRemovingSteps","oldPreviousSiblingImpl","oldNextSiblingImpl","remove","hasSlotDescendant","descendantImpl","module","exports"],"sources":["/Users/bernard/Downloads/my-app/node_modules/jsdom/lib/jsdom/living/nodes/Node-impl.js"],"sourcesContent":["\"use strict\";\n\nconst DOMException = require(\"domexception/webidl2js-wrapper\");\n\nconst EventTargetImpl = require(\"../events/EventTarget-impl\").implementation;\nconst { simultaneousIterators } = require(\"../../utils\");\nconst NODE_TYPE = require(\"../node-type\");\nconst NODE_DOCUMENT_POSITION = require(\"../node-document-position\");\nconst { clone, locateNamespacePrefix, locateNamespace } = require(\"../node\");\nconst { setAnExistingAttributeValue } = require(\"../attributes\");\n\nconst NodeList = require(\"../generated/NodeList\");\n\nconst { nodeRoot, nodeLength, isInclusiveAncestor } = require(\"../helpers/node\");\nconst { domSymbolTree } = require(\"../helpers/internal-constants\");\nconst { documentBaseURLSerialized } = require(\"../helpers/document-base-url\");\nconst { queueTreeMutationRecord } = require(\"../helpers/mutation-observers\");\nconst { enqueueCECallbackReaction, tryUpgradeElement } = require(\"../helpers/custom-elements\");\nconst {\n  isShadowRoot, shadowIncludingRoot, assignSlot, assignSlotableForTree, assignSlotable, signalSlotChange, isSlot,\n  shadowIncludingInclusiveDescendantsIterator, shadowIncludingDescendantsIterator\n} = require(\"../helpers/shadow-dom\");\nconst { invalidateStyleCache } = require(\"../helpers/style-rules\");\n\nfunction nodeEquals(a, b) {\n  if (a.nodeType !== b.nodeType) {\n    return false;\n  }\n\n  switch (a.nodeType) {\n    case NODE_TYPE.DOCUMENT_TYPE_NODE:\n      if (a.name !== b.name || a.publicId !== b.publicId ||\n          a.systemId !== b.systemId) {\n        return false;\n      }\n      break;\n    case NODE_TYPE.ELEMENT_NODE:\n      if (a._namespaceURI !== b._namespaceURI || a._prefix !== b._prefix || a._localName !== b._localName ||\n          a._attributes.length !== b._attributes.length) {\n        return false;\n      }\n      break;\n    case NODE_TYPE.ATTRIBUTE_NODE:\n      if (a._namespace !== b._namespace || a._localName !== b._localName || a._value !== b._value) {\n        return false;\n      }\n      break;\n    case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      if (a._target !== b._target || a._data !== b._data) {\n        return false;\n      }\n      break;\n    case NODE_TYPE.TEXT_NODE:\n    case NODE_TYPE.COMMENT_NODE:\n      if (a._data !== b._data) {\n        return false;\n      }\n      break;\n  }\n\n  if (a.nodeType === NODE_TYPE.ELEMENT_NODE && !attributeListsEqual(a, b)) {\n    return false;\n  }\n\n  for (const nodes of simultaneousIterators(domSymbolTree.childrenIterator(a), domSymbolTree.childrenIterator(b))) {\n    if (!nodes[0] || !nodes[1]) {\n      // mismatch in the amount of childNodes\n      return false;\n    }\n\n    if (!nodeEquals(nodes[0], nodes[1])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n// Needed by https://dom.spec.whatwg.org/#concept-node-equals\nfunction attributeListsEqual(elementA, elementB) {\n  const listA = elementA._attributeList;\n  const listB = elementB._attributeList;\n\n  const lengthA = listA.length;\n  const lengthB = listB.length;\n\n  if (lengthA !== lengthB) {\n    return false;\n  }\n\n  for (let i = 0; i < lengthA; ++i) {\n    const attrA = listA[i];\n\n    if (!listB.some(attrB => nodeEquals(attrA, attrB))) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n// https://dom.spec.whatwg.org/#concept-tree-host-including-inclusive-ancestor\nfunction isHostInclusiveAncestor(nodeImplA, nodeImplB) {\n  for (const ancestor of domSymbolTree.ancestorsIterator(nodeImplB)) {\n    if (ancestor === nodeImplA) {\n      return true;\n    }\n  }\n\n  const rootImplB = nodeRoot(nodeImplB);\n  if (rootImplB._host) {\n    return isHostInclusiveAncestor(nodeImplA, rootImplB._host);\n  }\n\n  return false;\n}\n\nclass NodeImpl extends EventTargetImpl {\n  constructor(globalObject, args, privateData) {\n    super(globalObject, args, privateData);\n\n    domSymbolTree.initialize(this);\n\n    this._ownerDocument = privateData.ownerDocument;\n\n    this._childNodesList = null;\n    this._childrenList = null;\n    this._version = 0;\n    this._memoizedQueries = {};\n    this._registeredObserverList = [];\n    this._referencedRanges = new Set();\n  }\n\n  _getTheParent() {\n    if (this._assignedSlot) {\n      return this._assignedSlot;\n    }\n\n    return domSymbolTree.parent(this);\n  }\n\n  get parentNode() {\n    return domSymbolTree.parent(this);\n  }\n\n  getRootNode(options) {\n    return options.composed ? shadowIncludingRoot(this) : nodeRoot(this);\n  }\n\n  get nodeName() {\n    switch (this.nodeType) {\n      case NODE_TYPE.ELEMENT_NODE:\n        return this.tagName;\n      case NODE_TYPE.ATTRIBUTE_NODE:\n        return this._qualifiedName;\n      case NODE_TYPE.TEXT_NODE:\n        return \"#text\";\n      case NODE_TYPE.CDATA_SECTION_NODE:\n        return \"#cdata-section\";\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n        return this.target;\n      case NODE_TYPE.COMMENT_NODE:\n        return \"#comment\";\n      case NODE_TYPE.DOCUMENT_NODE:\n        return \"#document\";\n      case NODE_TYPE.DOCUMENT_TYPE_NODE:\n        return this.name;\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n        return \"#document-fragment\";\n    }\n\n    // should never happen\n    return null;\n  }\n\n  get firstChild() {\n    return domSymbolTree.firstChild(this);\n  }\n\n  // https://dom.spec.whatwg.org/#connected\n  // https://dom.spec.whatwg.org/#dom-node-isconnected\n  get isConnected() {\n    const root = shadowIncludingRoot(this);\n    return root && root.nodeType === NODE_TYPE.DOCUMENT_NODE;\n  }\n\n  get ownerDocument() {\n    return this.nodeType === NODE_TYPE.DOCUMENT_NODE ? null : this._ownerDocument;\n  }\n\n  get lastChild() {\n    return domSymbolTree.lastChild(this);\n  }\n\n  get childNodes() {\n    if (!this._childNodesList) {\n      this._childNodesList = NodeList.createImpl(this._globalObject, [], {\n        element: this,\n        query: () => domSymbolTree.childrenToArray(this)\n      });\n    } else {\n      this._childNodesList._update();\n    }\n\n    return this._childNodesList;\n  }\n\n  get nextSibling() {\n    return domSymbolTree.nextSibling(this);\n  }\n\n  get previousSibling() {\n    return domSymbolTree.previousSibling(this);\n  }\n\n  _modified() {\n    this._version++;\n    for (const ancestor of domSymbolTree.ancestorsIterator(this)) {\n      ancestor._version++;\n    }\n\n    if (this._childrenList) {\n      this._childrenList._update();\n    }\n    if (this._childNodesList) {\n      this._childNodesList._update();\n    }\n    this._clearMemoizedQueries();\n    invalidateStyleCache(this);\n  }\n\n  _childTextContentChangeSteps() {\n    invalidateStyleCache(this);\n  }\n\n  _clearMemoizedQueries() {\n    this._memoizedQueries = {};\n    const myParent = domSymbolTree.parent(this);\n    if (myParent) {\n      myParent._clearMemoizedQueries();\n    }\n  }\n\n  _descendantRemoved(parent, child) {\n    const myParent = domSymbolTree.parent(this);\n    if (myParent) {\n      myParent._descendantRemoved(parent, child);\n    }\n  }\n\n  _descendantAdded(parent, child) {\n    const myParent = domSymbolTree.parent(this);\n    if (myParent) {\n      myParent._descendantAdded(parent, child);\n    }\n  }\n\n  _attach() {\n    this._attached = true;\n\n    for (const child of domSymbolTree.childrenIterator(this)) {\n      if (child._attach) {\n        child._attach();\n      }\n    }\n  }\n\n  _detach() {\n    this._attached = false;\n\n    if (this._ownerDocument && this._ownerDocument._lastFocusedElement === this) {\n      this._ownerDocument._lastFocusedElement = null;\n    }\n\n    for (const child of domSymbolTree.childrenIterator(this)) {\n      if (child._detach) {\n        child._detach();\n      }\n    }\n  }\n\n  hasChildNodes() {\n    return domSymbolTree.hasChildren(this);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-node-normalize\n  normalize() {\n    // It is important to use a treeToArray instead of a treeToIterator here, because the\n    // treeToIterator doesn't support tree mutation in the middle of the traversal.\n    for (const node of domSymbolTree.treeToArray(this)) {\n      const parentNode = domSymbolTree.parent(node);\n      if (parentNode === null || node.nodeType !== NODE_TYPE.TEXT_NODE) {\n        continue;\n      }\n\n      let length = nodeLength(node);\n\n      if (length === 0) {\n        parentNode._remove(node);\n        continue;\n      }\n\n      const continuousExclusiveTextNodes = [];\n\n      for (const currentNode of domSymbolTree.previousSiblingsIterator(node)) {\n        if (currentNode.nodeType !== NODE_TYPE.TEXT_NODE) {\n          break;\n        }\n\n        continuousExclusiveTextNodes.unshift(currentNode);\n      }\n      for (const currentNode of domSymbolTree.nextSiblingsIterator(node)) {\n        if (currentNode.nodeType !== NODE_TYPE.TEXT_NODE) {\n          break;\n        }\n\n        continuousExclusiveTextNodes.push(currentNode);\n      }\n\n      const data = continuousExclusiveTextNodes.reduce((d, n) => d + n._data, \"\");\n      node.replaceData(length, 0, data);\n\n      let currentNode = domSymbolTree.nextSibling(node);\n      while (currentNode && currentNode.nodeType === NODE_TYPE.TEXT_NODE) {\n        const currentNodeIndex = domSymbolTree.index(currentNode);\n\n        for (const range of node._referencedRanges) {\n          const { _start, _end } = range;\n\n          if (_start.node === currentNode) {\n            range._setLiveRangeStart(node, _start.offset + length);\n          }\n          if (_end.node === currentNode) {\n            range._setLiveRangeEnd(node, _end.offset + length);\n          }\n        }\n\n        for (const range of parentNode._referencedRanges) {\n          const { _start, _end } = range;\n\n          if (_start.node === parentNode && _start.offset === currentNodeIndex) {\n            range._setLiveRangeStart(node, length);\n          }\n          if (_end.node === parentNode && _end.offset === currentNodeIndex) {\n            range._setLiveRangeEnd(node, length);\n          }\n        }\n\n        length += nodeLength(currentNode);\n        currentNode = domSymbolTree.nextSibling(currentNode);\n      }\n\n      for (const continuousExclusiveTextNode of continuousExclusiveTextNodes) {\n        parentNode._remove(continuousExclusiveTextNode);\n      }\n    }\n  }\n\n  get parentElement() {\n    const parentNode = domSymbolTree.parent(this);\n    return parentNode !== null && parentNode.nodeType === NODE_TYPE.ELEMENT_NODE ? parentNode : null;\n  }\n\n  get baseURI() {\n    return documentBaseURLSerialized(this._ownerDocument);\n  }\n\n  compareDocumentPosition(other) {\n    // Let node1 be other and node2 be the context object.\n    let node1 = other;\n    let node2 = this;\n\n    let attr1 = null;\n    let attr2 = null;\n\n    if (node1.nodeType === NODE_TYPE.ATTRIBUTE_NODE) {\n      attr1 = node1;\n      node1 = attr1._element;\n    }\n\n    if (node2.nodeType === NODE_TYPE.ATTRIBUTE_NODE) {\n      attr2 = node2;\n      node2 = attr2._element;\n\n      if (attr1 !== null && node1 !== null && node2 === node1) {\n        for (const attr of node2._attributeList) {\n          if (nodeEquals(attr, attr1)) {\n            return NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC |\n              NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_PRECEDING;\n          }\n\n          if (nodeEquals(attr, attr2)) {\n            return NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC |\n              NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_FOLLOWING;\n          }\n        }\n      }\n    }\n\n    const result = domSymbolTree.compareTreePosition(node2, node1);\n\n    // “If other and reference are not in the same tree, return the result of adding DOCUMENT_POSITION_DISCONNECTED,\n    //  DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC, and either DOCUMENT_POSITION_PRECEDING or\n    // DOCUMENT_POSITION_FOLLOWING, with the constraint that this is to be consistent, together.”\n    if (result === NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_DISCONNECTED) {\n      // symbol-tree does not add these bits required by the spec:\n      return NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_DISCONNECTED |\n        NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC |\n        NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_FOLLOWING;\n    }\n\n    return result;\n  }\n\n  lookupPrefix(namespace) {\n    if (namespace === null || namespace === \"\") {\n      return null;\n    }\n\n    switch (this.nodeType) {\n      case NODE_TYPE.ELEMENT_NODE: {\n        return locateNamespacePrefix(this, namespace);\n      }\n      case NODE_TYPE.DOCUMENT_NODE: {\n        return this.documentElement !== null ? locateNamespacePrefix(this.documentElement, namespace) : null;\n      }\n      case NODE_TYPE.DOCUMENT_TYPE_NODE:\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE: {\n        return null;\n      }\n      case NODE_TYPE.ATTRIBUTE_NODE: {\n        return this._element !== null ? locateNamespacePrefix(this._element, namespace) : null;\n      }\n      default: {\n        return this.parentElement !== null ? locateNamespacePrefix(this.parentElement, namespace) : null;\n      }\n    }\n  }\n\n  lookupNamespaceURI(prefix) {\n    if (prefix === \"\") {\n      prefix = null;\n    }\n\n    return locateNamespace(this, prefix);\n  }\n\n  isDefaultNamespace(namespace) {\n    if (namespace === \"\") {\n      namespace = null;\n    }\n\n    const defaultNamespace = locateNamespace(this, null);\n    return defaultNamespace === namespace;\n  }\n\n  contains(other) {\n    return isInclusiveAncestor(this, other);\n  }\n\n  isEqualNode(node) {\n    if (node === null) {\n      return false;\n    }\n\n    // Fast-path, not in the spec\n    if (this === node) {\n      return true;\n    }\n\n    return nodeEquals(this, node);\n  }\n\n  isSameNode(node) {\n    if (this === node) {\n      return true;\n    }\n\n    return false;\n  }\n\n  cloneNode(deep) {\n    if (isShadowRoot(this)) {\n      throw DOMException.create(this._globalObject, [\"ShadowRoot nodes are not clonable.\", \"NotSupportedError\"]);\n    }\n\n    deep = Boolean(deep);\n\n    return clone(this, undefined, deep);\n  }\n\n  get nodeValue() {\n    switch (this.nodeType) {\n      case NODE_TYPE.ATTRIBUTE_NODE: {\n        return this._value;\n      }\n      case NODE_TYPE.TEXT_NODE:\n      case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      case NODE_TYPE.COMMENT_NODE: {\n        return this._data;\n      }\n      default: {\n        return null;\n      }\n    }\n  }\n\n  set nodeValue(value) {\n    if (value === null) {\n      value = \"\";\n    }\n\n    switch (this.nodeType) {\n      case NODE_TYPE.ATTRIBUTE_NODE: {\n        setAnExistingAttributeValue(this, value);\n        break;\n      }\n      case NODE_TYPE.TEXT_NODE:\n      case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      case NODE_TYPE.COMMENT_NODE: {\n        this.replaceData(0, this.length, value);\n        break;\n      }\n    }\n  }\n\n  // https://dom.spec.whatwg.org/#dom-node-textcontent\n  get textContent() {\n    switch (this.nodeType) {\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n      case NODE_TYPE.ELEMENT_NODE: {\n        let text = \"\";\n        for (const child of domSymbolTree.treeIterator(this)) {\n          if (child.nodeType === NODE_TYPE.TEXT_NODE || child.nodeType === NODE_TYPE.CDATA_SECTION_NODE) {\n            text += child.nodeValue;\n          }\n        }\n        return text;\n      }\n\n      case NODE_TYPE.ATTRIBUTE_NODE: {\n        return this._value;\n      }\n\n      case NODE_TYPE.TEXT_NODE:\n      case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      case NODE_TYPE.COMMENT_NODE: {\n        return this._data;\n      }\n\n      default: {\n        return null;\n      }\n    }\n  }\n  set textContent(value) {\n    if (value === null) {\n      value = \"\";\n    }\n\n    switch (this.nodeType) {\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n      case NODE_TYPE.ELEMENT_NODE: {\n        // https://dom.spec.whatwg.org/#string-replace-all\n        let nodeImpl = null;\n\n        if (value !== \"\") {\n          nodeImpl = this._ownerDocument.createTextNode(value);\n        }\n\n        this._replaceAll(nodeImpl);\n        break;\n      }\n\n      case NODE_TYPE.ATTRIBUTE_NODE: {\n        setAnExistingAttributeValue(this, value);\n        break;\n      }\n\n      case NODE_TYPE.TEXT_NODE:\n      case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      case NODE_TYPE.COMMENT_NODE: {\n        this.replaceData(0, this.length, value);\n        break;\n      }\n    }\n  }\n\n  // https://dom.spec.whatwg.org/#dom-node-insertbefore\n  insertBefore(nodeImpl, childImpl) {\n    return this._preInsert(nodeImpl, childImpl);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-node-appendchild\n  appendChild(nodeImpl) {\n    return this._append(nodeImpl);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-node-replacechild\n  replaceChild(nodeImpl, childImpl) {\n    return this._replace(nodeImpl, childImpl);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-node-removechild\n  removeChild(oldChildImpl) {\n    return this._preRemove(oldChildImpl);\n  }\n\n  // https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity\n  _preInsertValidity(nodeImpl, childImpl) {\n    const { nodeType, nodeName } = nodeImpl;\n    const { nodeType: parentType, nodeName: parentName } = this;\n\n    if (\n      parentType !== NODE_TYPE.DOCUMENT_NODE &&\n      parentType !== NODE_TYPE.DOCUMENT_FRAGMENT_NODE &&\n      parentType !== NODE_TYPE.ELEMENT_NODE\n    ) {\n      throw DOMException.create(this._globalObject, [\n        `Node can't be inserted in a ${parentName} parent.`,\n        \"HierarchyRequestError\"\n      ]);\n    }\n\n    if (isHostInclusiveAncestor(nodeImpl, this)) {\n      throw DOMException.create(this._globalObject, [\n        \"The operation would yield an incorrect node tree.\",\n        \"HierarchyRequestError\"\n      ]);\n    }\n\n    if (childImpl && domSymbolTree.parent(childImpl) !== this) {\n      throw DOMException.create(this._globalObject, [\n        \"The child can not be found in the parent.\",\n        \"NotFoundError\"\n      ]);\n    }\n\n    if (\n      nodeType !== NODE_TYPE.DOCUMENT_FRAGMENT_NODE &&\n      nodeType !== NODE_TYPE.DOCUMENT_TYPE_NODE &&\n      nodeType !== NODE_TYPE.ELEMENT_NODE &&\n      nodeType !== NODE_TYPE.TEXT_NODE &&\n      nodeType !== NODE_TYPE.CDATA_SECTION_NODE && // CData section extends from Text\n      nodeType !== NODE_TYPE.PROCESSING_INSTRUCTION_NODE &&\n      nodeType !== NODE_TYPE.COMMENT_NODE\n    ) {\n      throw DOMException.create(this._globalObject, [\n        `${nodeName} node can't be inserted in parent node.`,\n        \"HierarchyRequestError\"\n      ]);\n    }\n\n    if (\n      (nodeType === NODE_TYPE.TEXT_NODE && parentType === NODE_TYPE.DOCUMENT_NODE) ||\n      (nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE && parentType !== NODE_TYPE.DOCUMENT_NODE)\n    ) {\n      throw DOMException.create(this._globalObject, [\n        `${nodeName} node can't be inserted in ${parentName} parent.`,\n        \"HierarchyRequestError\"\n      ]);\n    }\n\n    if (parentType === NODE_TYPE.DOCUMENT_NODE) {\n      const nodeChildren = domSymbolTree.childrenToArray(nodeImpl);\n      const parentChildren = domSymbolTree.childrenToArray(this);\n\n      switch (nodeType) {\n        case NODE_TYPE.DOCUMENT_FRAGMENT_NODE: {\n          const nodeChildrenElements = nodeChildren.filter(child => child.nodeType === NODE_TYPE.ELEMENT_NODE);\n          if (nodeChildrenElements.length > 1) {\n            throw DOMException.create(this._globalObject, [\n              `Invalid insertion of ${nodeName} node in ${parentName} node.`,\n              \"HierarchyRequestError\"\n            ]);\n          }\n\n          const hasNodeTextChildren = nodeChildren.some(child => child.nodeType === NODE_TYPE.TEXT_NODE);\n          if (hasNodeTextChildren) {\n            throw DOMException.create(this._globalObject, [\n              `Invalid insertion of ${nodeName} node in ${parentName} node.`,\n              \"HierarchyRequestError\"\n            ]);\n          }\n\n          if (\n            nodeChildrenElements.length === 1 &&\n            (\n              parentChildren.some(child => child.nodeType === NODE_TYPE.ELEMENT_NODE) ||\n              (childImpl && childImpl.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) ||\n              (\n                childImpl &&\n                domSymbolTree.nextSibling(childImpl) &&\n                domSymbolTree.nextSibling(childImpl).nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE\n              )\n            )\n          ) {\n            throw DOMException.create(this._globalObject, [\n              `Invalid insertion of ${nodeName} node in ${parentName} node.`,\n              \"HierarchyRequestError\"\n            ]);\n          }\n          break;\n        }\n\n        case NODE_TYPE.ELEMENT_NODE:\n          if (\n            parentChildren.some(child => child.nodeType === NODE_TYPE.ELEMENT_NODE) ||\n            (childImpl && childImpl.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) ||\n            (\n              childImpl &&\n              domSymbolTree.nextSibling(childImpl) &&\n              domSymbolTree.nextSibling(childImpl).nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE\n            )\n          ) {\n            throw DOMException.create(this._globalObject, [\n              `Invalid insertion of ${nodeName} node in ${parentName} node.`,\n              \"HierarchyRequestError\"\n            ]);\n          }\n          break;\n\n        case NODE_TYPE.DOCUMENT_TYPE_NODE:\n          if (\n            parentChildren.some(child => child.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) ||\n            (\n              childImpl &&\n              domSymbolTree.previousSibling(childImpl) &&\n              domSymbolTree.previousSibling(childImpl).nodeType === NODE_TYPE.ELEMENT_NODE\n            ) ||\n            (!childImpl && parentChildren.some(child => child.nodeType === NODE_TYPE.ELEMENT_NODE))\n          ) {\n            throw DOMException.create(this._globalObject, [\n              `Invalid insertion of ${nodeName} node in ${parentName} node.`,\n              \"HierarchyRequestError\"\n            ]);\n          }\n          break;\n      }\n    }\n  }\n\n  // https://dom.spec.whatwg.org/#concept-node-pre-insert\n  _preInsert(nodeImpl, childImpl) {\n    this._preInsertValidity(nodeImpl, childImpl);\n\n    let referenceChildImpl = childImpl;\n    if (referenceChildImpl === nodeImpl) {\n      referenceChildImpl = domSymbolTree.nextSibling(nodeImpl);\n    }\n\n    this._ownerDocument._adoptNode(nodeImpl);\n\n    this._insert(nodeImpl, referenceChildImpl);\n\n    return nodeImpl;\n  }\n\n  // https://dom.spec.whatwg.org/#concept-node-insert\n  _insert(nodeImpl, childImpl, suppressObservers) {\n    const count = nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE ?\n        domSymbolTree.childrenCount(nodeImpl) :\n        1;\n\n    if (childImpl) {\n      const childIndex = domSymbolTree.index(childImpl);\n\n      for (const range of this._referencedRanges) {\n        const { _start, _end } = range;\n\n        if (_start.offset > childIndex) {\n          range._setLiveRangeStart(this, _start.offset + count);\n        }\n\n        if (_end.offset > childIndex) {\n          range._setLiveRangeEnd(this, _end.offset + count);\n        }\n      }\n    }\n\n    const nodesImpl = nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE ?\n      domSymbolTree.childrenToArray(nodeImpl) :\n      [nodeImpl];\n\n    if (nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE) {\n      let grandChildImpl;\n      while ((grandChildImpl = domSymbolTree.firstChild(nodeImpl))) {\n        nodeImpl._remove(grandChildImpl, true);\n      }\n    }\n\n    if (nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE) {\n      queueTreeMutationRecord(nodeImpl, [], nodesImpl, null, null);\n    }\n\n    const previousChildImpl = childImpl ?\n      domSymbolTree.previousSibling(childImpl) :\n      domSymbolTree.lastChild(this);\n\n    let isConnected;\n\n    for (const node of nodesImpl) {\n      if (!childImpl) {\n        domSymbolTree.appendChild(this, node);\n      } else {\n        domSymbolTree.insertBefore(childImpl, node);\n      }\n\n      if (\n        (this.nodeType === NODE_TYPE.ELEMENT_NODE && this._shadowRoot !== null) &&\n        (node.nodeType === NODE_TYPE.ELEMENT_NODE || node.nodeType === NODE_TYPE.TEXT_NODE)\n      ) {\n        assignSlot(node);\n      }\n\n      this._modified();\n\n      if (node.nodeType === NODE_TYPE.TEXT_NODE ||\n          node.nodeType === NODE_TYPE.CDATA_SECTION_NODE) {\n        this._childTextContentChangeSteps();\n      }\n\n      if (isSlot(this) && this._assignedNodes.length === 0 && isShadowRoot(nodeRoot(this))) {\n        signalSlotChange(this);\n      }\n\n      const root = nodeRoot(node);\n      if (isShadowRoot(root)) {\n        assignSlotableForTree(root);\n      }\n\n      if (this._attached && nodeImpl._attach) {\n        node._attach();\n      }\n\n      this._descendantAdded(this, node);\n\n      if (isConnected === undefined) {\n        isConnected = node.isConnected;\n      }\n\n      if (isConnected) {\n        for (const inclusiveDescendant of shadowIncludingInclusiveDescendantsIterator(node)) {\n          if (inclusiveDescendant._ceState === \"custom\") {\n            enqueueCECallbackReaction(inclusiveDescendant, \"connectedCallback\", []);\n          } else {\n            tryUpgradeElement(inclusiveDescendant);\n          }\n        }\n      }\n    }\n\n    if (!suppressObservers) {\n      queueTreeMutationRecord(this, nodesImpl, [], previousChildImpl, childImpl);\n    }\n  }\n\n  // https://dom.spec.whatwg.org/#concept-node-append\n  _append(nodeImpl) {\n    return this._preInsert(nodeImpl, null);\n  }\n\n  // https://dom.spec.whatwg.org/#concept-node-replace\n  _replace(nodeImpl, childImpl) {\n    const { nodeType, nodeName } = nodeImpl;\n    const { nodeType: parentType, nodeName: parentName } = this;\n\n    // Note: This section differs from the pre-insert validation algorithm.\n    if (\n      parentType !== NODE_TYPE.DOCUMENT_NODE &&\n      parentType !== NODE_TYPE.DOCUMENT_FRAGMENT_NODE &&\n      parentType !== NODE_TYPE.ELEMENT_NODE\n    ) {\n      throw DOMException.create(this._globalObject, [\n        `Node can't be inserted in a ${parentName} parent.`,\n        \"HierarchyRequestError\"\n      ]);\n    }\n\n    if (isHostInclusiveAncestor(nodeImpl, this)) {\n      throw DOMException.create(this._globalObject, [\n        \"The operation would yield an incorrect node tree.\",\n        \"HierarchyRequestError\"\n      ]);\n    }\n\n    if (childImpl && domSymbolTree.parent(childImpl) !== this) {\n      throw DOMException.create(this._globalObject, [\n        \"The child can not be found in the parent.\",\n        \"NotFoundError\"\n      ]);\n    }\n\n    if (\n      nodeType !== NODE_TYPE.DOCUMENT_FRAGMENT_NODE &&\n      nodeType !== NODE_TYPE.DOCUMENT_TYPE_NODE &&\n      nodeType !== NODE_TYPE.ELEMENT_NODE &&\n      nodeType !== NODE_TYPE.TEXT_NODE &&\n      nodeType !== NODE_TYPE.CDATA_SECTION_NODE && // CData section extends from Text\n      nodeType !== NODE_TYPE.PROCESSING_INSTRUCTION_NODE &&\n      nodeType !== NODE_TYPE.COMMENT_NODE\n    ) {\n      throw DOMException.create(this._globalObject, [\n        `${nodeName} node can't be inserted in parent node.`,\n        \"HierarchyRequestError\"\n      ]);\n    }\n\n    if (\n      (nodeType === NODE_TYPE.TEXT_NODE && parentType === NODE_TYPE.DOCUMENT_NODE) ||\n      (nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE && parentType !== NODE_TYPE.DOCUMENT_NODE)\n    ) {\n      throw DOMException.create(this._globalObject, [\n        `${nodeName} node can't be inserted in ${parentName} parent.`,\n        \"HierarchyRequestError\"\n      ]);\n    }\n\n    if (parentType === NODE_TYPE.DOCUMENT_NODE) {\n      const nodeChildren = domSymbolTree.childrenToArray(nodeImpl);\n      const parentChildren = domSymbolTree.childrenToArray(this);\n\n      switch (nodeType) {\n        case NODE_TYPE.DOCUMENT_FRAGMENT_NODE: {\n          const nodeChildrenElements = nodeChildren.filter(child => child.nodeType === NODE_TYPE.ELEMENT_NODE);\n          if (nodeChildrenElements.length > 1) {\n            throw DOMException.create(this._globalObject, [\n              `Invalid insertion of ${nodeName} node in ${parentName} node.`,\n              \"HierarchyRequestError\"\n            ]);\n          }\n\n          const hasNodeTextChildren = nodeChildren.some(child => child.nodeType === NODE_TYPE.TEXT_NODE);\n          if (hasNodeTextChildren) {\n            throw DOMException.create(this._globalObject, [\n              `Invalid insertion of ${nodeName} node in ${parentName} node.`,\n              \"HierarchyRequestError\"\n            ]);\n          }\n\n\n          const parentChildElements = parentChildren.filter(child => child.nodeType === NODE_TYPE.ELEMENT_NODE);\n          if (\n            nodeChildrenElements.length === 1 &&\n            (\n              (parentChildElements.length === 1 && parentChildElements[0] !== childImpl) ||\n              (\n                childImpl &&\n                domSymbolTree.nextSibling(childImpl) &&\n                domSymbolTree.nextSibling(childImpl).nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE\n              )\n            )\n          ) {\n            throw DOMException.create(this._globalObject, [\n              `Invalid insertion of ${nodeName} node in ${parentName} node.`,\n              \"HierarchyRequestError\"\n            ]);\n          }\n          break;\n        }\n\n        case NODE_TYPE.ELEMENT_NODE:\n          if (\n            parentChildren.some(child => child.nodeType === NODE_TYPE.ELEMENT_NODE && child !== childImpl) ||\n            (\n              childImpl &&\n              domSymbolTree.nextSibling(childImpl) &&\n              domSymbolTree.nextSibling(childImpl).nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE\n            )\n          ) {\n            throw DOMException.create(this._globalObject, [\n              `Invalid insertion of ${nodeName} node in ${parentName} node.`,\n              \"HierarchyRequestError\"\n            ]);\n          }\n          break;\n\n        case NODE_TYPE.DOCUMENT_TYPE_NODE:\n          if (\n            parentChildren.some(child => child.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE && child !== childImpl) ||\n            (\n              childImpl &&\n              domSymbolTree.previousSibling(childImpl) &&\n              domSymbolTree.previousSibling(childImpl).nodeType === NODE_TYPE.ELEMENT_NODE\n            )\n          ) {\n            throw DOMException.create(this._globalObject, [\n              `Invalid insertion of ${nodeName} node in ${parentName} node.`,\n              \"HierarchyRequestError\"\n            ]);\n          }\n          break;\n      }\n    }\n\n    let referenceChildImpl = domSymbolTree.nextSibling(childImpl);\n    if (referenceChildImpl === nodeImpl) {\n      referenceChildImpl = domSymbolTree.nextSibling(nodeImpl);\n    }\n\n    const previousSiblingImpl = domSymbolTree.previousSibling(childImpl);\n\n    this._ownerDocument._adoptNode(nodeImpl);\n\n    let removedNodesImpl = [];\n\n    if (domSymbolTree.parent(childImpl)) {\n      removedNodesImpl = [childImpl];\n      this._remove(childImpl, true);\n    }\n\n    const nodesImpl = nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE ?\n      domSymbolTree.childrenToArray(nodeImpl) :\n      [nodeImpl];\n\n    this._insert(nodeImpl, referenceChildImpl, true);\n\n    queueTreeMutationRecord(this, nodesImpl, removedNodesImpl, previousSiblingImpl, referenceChildImpl);\n\n    return childImpl;\n  }\n\n  // https://dom.spec.whatwg.org/#concept-node-replace-all\n  _replaceAll(nodeImpl) {\n    if (nodeImpl !== null) {\n      this._ownerDocument._adoptNode(nodeImpl);\n    }\n\n    const removedNodesImpl = domSymbolTree.childrenToArray(this);\n\n    let addedNodesImpl;\n    if (nodeImpl === null) {\n      addedNodesImpl = [];\n    } else if (nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE) {\n      addedNodesImpl = domSymbolTree.childrenToArray(nodeImpl);\n    } else {\n      addedNodesImpl = [nodeImpl];\n    }\n\n    for (const childImpl of domSymbolTree.childrenIterator(this)) {\n      this._remove(childImpl, true);\n    }\n\n    if (nodeImpl !== null) {\n      this._insert(nodeImpl, null, true);\n    }\n\n    if (addedNodesImpl.length > 0 || removedNodesImpl.length > 0) {\n      queueTreeMutationRecord(this, addedNodesImpl, removedNodesImpl, null, null);\n    }\n  }\n\n  // https://dom.spec.whatwg.org/#concept-node-pre-remove\n  _preRemove(childImpl) {\n    if (domSymbolTree.parent(childImpl) !== this) {\n      throw DOMException.create(this._globalObject, [\n        \"The node to be removed is not a child of this node.\",\n        \"NotFoundError\"\n      ]);\n    }\n\n    this._remove(childImpl);\n\n    return childImpl;\n  }\n\n  // https://dom.spec.whatwg.org/#concept-node-remove\n  _remove(nodeImpl, suppressObservers) {\n    const index = domSymbolTree.index(nodeImpl);\n\n    for (const descendant of domSymbolTree.treeIterator(nodeImpl)) {\n      for (const range of descendant._referencedRanges) {\n        const { _start, _end } = range;\n\n        if (_start.node === descendant) {\n          range._setLiveRangeStart(this, index);\n        }\n\n        if (_end.node === descendant) {\n          range._setLiveRangeEnd(this, index);\n        }\n      }\n    }\n\n    for (const range of this._referencedRanges) {\n      const { _start, _end } = range;\n\n      if (_start.node === this && _start.offset > index) {\n        range._setLiveRangeStart(this, _start.offset - 1);\n      }\n\n      if (_end.node === this && _end.offset > index) {\n        range._setLiveRangeEnd(this, _end.offset - 1);\n      }\n    }\n\n    if (this._ownerDocument) {\n      this._ownerDocument._runPreRemovingSteps(nodeImpl);\n    }\n\n    const oldPreviousSiblingImpl = domSymbolTree.previousSibling(nodeImpl);\n    const oldNextSiblingImpl = domSymbolTree.nextSibling(nodeImpl);\n\n    domSymbolTree.remove(nodeImpl);\n\n    if (nodeImpl._assignedSlot) {\n      assignSlotable(nodeImpl._assignedSlot);\n    }\n\n    if (isSlot(this) && this._assignedNodes.length === 0 && isShadowRoot(nodeRoot(this))) {\n      signalSlotChange(this);\n    }\n\n    let hasSlotDescendant = isSlot(nodeImpl);\n    if (!hasSlotDescendant) {\n      for (const child of domSymbolTree.treeIterator(nodeImpl)) {\n        if (isSlot(child)) {\n          hasSlotDescendant = true;\n          break;\n        }\n      }\n    }\n\n    if (hasSlotDescendant) {\n      assignSlotableForTree(nodeRoot(this));\n      assignSlotableForTree(nodeImpl);\n    }\n\n    this._modified();\n    nodeImpl._detach();\n    this._descendantRemoved(this, nodeImpl);\n\n    if (this.isConnected) {\n      if (nodeImpl._ceState === \"custom\") {\n        enqueueCECallbackReaction(nodeImpl, \"disconnectedCallback\", []);\n      }\n\n      for (const descendantImpl of shadowIncludingDescendantsIterator(nodeImpl)) {\n        if (descendantImpl._ceState === \"custom\") {\n          enqueueCECallbackReaction(descendantImpl, \"disconnectedCallback\", []);\n        }\n      }\n    }\n\n    if (!suppressObservers) {\n      queueTreeMutationRecord(this, [], [nodeImpl], oldPreviousSiblingImpl, oldNextSiblingImpl);\n    }\n\n    if (nodeImpl.nodeType === NODE_TYPE.TEXT_NODE) {\n      this._childTextContentChangeSteps();\n    }\n  }\n}\n\nmodule.exports = {\n  implementation: NodeImpl\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}