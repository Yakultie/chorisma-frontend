{"ast":null,"code":"\"use strict\";\n\nconst nodeURL = require(\"url\");\nconst DOMException = require(\"domexception/webidl2js-wrapper\");\nconst {\n  parseURL,\n  serializeURL,\n  serializeURLOrigin\n} = require(\"whatwg-url\");\nconst WebSocket = require(\"ws\");\nconst {\n  setupForSimpleEventAccessors\n} = require(\"../helpers/create-event-accessor\");\nconst {\n  fireAnEvent\n} = require(\"../helpers/events\");\nconst {\n  isArrayBuffer\n} = require(\"../generated/utils\");\nconst {\n  copyToArrayBufferInNewRealm\n} = require(\"../helpers/binary-data\");\nconst EventTargetImpl = require(\"../events/EventTarget-impl\").implementation;\nconst idlUtils = require(\"../generated/utils\");\nconst Blob = require(\"../generated/Blob\");\nconst CloseEvent = require(\"../generated/CloseEvent\");\nconst MessageEvent = require(\"../generated/MessageEvent\");\nconst CONNECTING = 0;\nconst OPEN = 1;\nconst CLOSING = 2;\nconst CLOSED = 3;\nconst productions = {\n  // https://tools.ietf.org/html/rfc7230#section-3.2.6\n  token: /^[!#$%&'*+\\-.^_`|~\\dA-Za-z]+$/\n};\nconst readyStateWSToDOM = [];\nreadyStateWSToDOM[WebSocket.CONNECTING] = CONNECTING;\nreadyStateWSToDOM[WebSocket.OPEN] = OPEN;\nreadyStateWSToDOM[WebSocket.CLOSING] = CLOSING;\nreadyStateWSToDOM[WebSocket.CLOSED] = CLOSED;\n\n// https://tools.ietf.org/html/rfc6455#section-4.3\n// See Sec-WebSocket-Protocol-Client, which is for the syntax of an entire header value. This function checks if a\n// single header conforms to the rules.\nfunction verifySecWebSocketProtocol(str) {\n  return productions.token.test(str);\n}\nclass PromiseQueues extends WeakMap {\n  get(window) {\n    const cur = super.get(window);\n    return cur !== undefined ? cur : Promise.resolve();\n  }\n}\nconst openSockets = new WeakMap();\nconst openingQueues = new PromiseQueues();\nclass WebSocketImpl extends EventTargetImpl {\n  constructor(globalObject, args, privateData) {\n    var _this;\n    super(globalObject, args, privateData);\n    _this = this;\n    this._ownerDocument = idlUtils.implForWrapper(globalObject._document);\n    const url = args[0];\n    let protocols = args[1] !== undefined ? args[1] : [];\n    const urlRecord = parseURL(url);\n    if (urlRecord === null) {\n      throw DOMException.create(this._globalObject, [`The URL '${url}' is invalid.`, \"SyntaxError\"]);\n    }\n    if (urlRecord.scheme !== \"ws\" && urlRecord.scheme !== \"wss\") {\n      throw DOMException.create(this._globalObject, [`The URL's scheme must be either 'ws' or 'wss'. '${urlRecord.scheme}' is not allowed.`, \"SyntaxError\"]);\n    }\n    if (urlRecord.fragment !== null) {\n      throw DOMException.create(this._globalObject, [`The URL contains a fragment identifier ('${urlRecord.fragment}'). Fragment identifiers ` + \"are not allowed in WebSocket URLs.\", \"SyntaxError\"]);\n    }\n    if (typeof protocols === \"string\") {\n      protocols = [protocols];\n    }\n    const protocolSet = new Set();\n    for (const protocol of protocols) {\n      if (!verifySecWebSocketProtocol(protocol)) {\n        throw DOMException.create(this._globalObject, [`The subprotocol '${protocol}' is invalid.`, \"SyntaxError\"]);\n      }\n      const lowered = protocol.toLowerCase();\n      if (protocolSet.has(lowered)) {\n        throw DOMException.create(this._globalObject, [`The subprotocol '${protocol}' is duplicated.`, \"SyntaxError\"]);\n      }\n      protocolSet.add(lowered);\n    }\n    this._urlRecord = urlRecord;\n    this.url = serializeURL(urlRecord);\n    const nodeParsedURL = nodeURL.parse(this.url);\n    this.extensions = \"\";\n    this.binaryType = \"blob\";\n    this._ws = null;\n    // Used when this._ws has not been initialized yet.\n    this._readyState = CONNECTING;\n    this._requiredToFail = false;\n    this.bufferedAmount = 0;\n    this._sendQueue = [];\n    let openSocketsForWindow = openSockets.get(globalObject._globalProxy);\n    if (openSocketsForWindow === undefined) {\n      openSocketsForWindow = new Set();\n      openSockets.set(globalObject._globalProxy, openSocketsForWindow);\n    }\n    openSocketsForWindow.add(this);\n    openingQueues.set(this._ownerDocument, openingQueues.get(this._ownerDocument).then(() => new Promise(resolve => {\n      // close() called before _ws has been initialized.\n      if (this._requiredToFail) {\n        resolve();\n        this._readyState = CLOSED;\n        this._onConnectionClosed(1006, \"\");\n        return;\n      }\n      this._ws = new WebSocket(this.url, protocols, {\n        headers: {\n          \"user-agent\": globalObject.navigator.userAgent,\n          \"cookie\": this._ownerDocument._cookieJar.getCookieStringSync(nodeParsedURL, {\n            http: true\n          }),\n          \"origin\": globalObject._origin\n        },\n        rejectUnauthorized: globalObject._resourceLoader._strictSSL\n      });\n      this._ws.once(\"open\", () => {\n        resolve();\n        this._onConnectionEstablished();\n      });\n      this._ws.on(\"message\", this._onMessageReceived.bind(this));\n      this._ws.once(\"close\", function () {\n        resolve();\n        _this._onConnectionClosed(...arguments);\n      });\n      this._ws.once(\"upgrade\", _ref => {\n        let {\n          headers\n        } = _ref;\n        if (Array.isArray(headers[\"set-cookie\"])) {\n          for (const cookie of headers[\"set-cookie\"]) {\n            this._ownerDocument._cookieJar.setCookieSync(cookie, nodeParsedURL, {\n              http: true,\n              ignoreError: true\n            });\n          }\n        } else if (headers[\"set-cookie\"] !== undefined) {\n          this._ownerDocument._cookieJar.setCookieSync(headers[\"set-cookie\"], nodeParsedURL, {\n            http: true,\n            ignoreError: true\n          });\n        }\n      });\n      this._ws.once(\"error\", () => {\n        // The exact error is passed into this callback, but it is ignored as we don't really care about it.\n        resolve();\n        this._requiredToFail = true;\n        // Do not emit an error here, as that will be handled in _onConnectionClosed. ws always emits a close event\n        // after errors.\n      });\n    })));\n  }\n\n  // https://html.spec.whatwg.org/multipage/web-sockets.html#make-disappear\n  _makeDisappear() {\n    this._eventListeners = Object.create(null);\n    this._close(1001);\n  }\n  static cleanUpWindow(window) {\n    const openSocketsForWindow = openSockets.get(window._globalProxy);\n    if (openSocketsForWindow !== undefined) {\n      for (const ws of openSocketsForWindow) {\n        ws._makeDisappear();\n      }\n    }\n  }\n\n  // https://html.spec.whatwg.org/multipage/web-sockets.html#feedback-from-the-protocol\n  _onConnectionEstablished() {\n    // readyState is a getter.\n    if (this._ws.extensions !== null) {\n      // Right now, ws only supports one extension, permessage-deflate, without any parameters. This algorithm may need\n      // to be more sophiscated as more extenions are supported.\n      this.extensions = Object.keys(this._ws.extensions).join(\", \");\n    }\n    // protocol is a getter.\n    fireAnEvent(\"open\", this);\n  }\n  _onMessageReceived(data, isBinary) {\n    if (this.readyState !== OPEN) {\n      return;\n    }\n    let dataForEvent;\n    if (!isBinary) {\n      dataForEvent = data.toString();\n    } else if (this.binaryType === \"arraybuffer\") {\n      if (isArrayBuffer(data)) {\n        dataForEvent = data;\n      } else if (Array.isArray(data)) {\n        dataForEvent = copyToArrayBufferInNewRealm(Buffer.concat(data), this._globalObject);\n      } else {\n        dataForEvent = copyToArrayBufferInNewRealm(data, this._globalObject);\n      }\n    } else {\n      // this.binaryType === \"blob\"\n      if (!Array.isArray(data)) {\n        data = [data];\n      }\n      dataForEvent = Blob.create(this._globalObject, [data, {\n        type: \"\"\n      }]);\n    }\n    fireAnEvent(\"message\", this, MessageEvent, {\n      data: dataForEvent,\n      origin: serializeURLOrigin(this._urlRecord)\n    });\n  }\n  _onConnectionClosed(code, reason) {\n    const openSocketsForWindow = openSockets.get(this._ownerDocument._defaultView);\n    openSocketsForWindow.delete(this);\n    const wasClean = !this._requiredToFail;\n    if (this._requiredToFail) {\n      fireAnEvent(\"error\", this);\n    }\n    fireAnEvent(\"close\", this, CloseEvent, {\n      wasClean,\n      code,\n      reason: reason.toString()\n    });\n  }\n  get readyState() {\n    if (this._ws !== null) {\n      return readyStateWSToDOM[this._ws.readyState];\n    }\n    return this._readyState;\n  }\n  get protocol() {\n    if (this._ws === null) {\n      return \"\";\n    }\n    return this._ws.protocol;\n  }\n  close() {\n    let code = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n    let reason = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    if (code !== undefined && code !== 1000 && !(code >= 3000 && code <= 4999)) {\n      throw DOMException.create(this._globalObject, [`The code must be either 1000, or between 3000 and 4999. ${code} is neither.`, \"InvalidAccessError\"]);\n    }\n    if (reason !== undefined && Buffer.byteLength(reason, \"utf8\") > 123) {\n      throw DOMException.create(this._globalObject, [\"The message must not be greater than 123 bytes.\", \"SyntaxError\"]);\n    }\n    this._close(code, reason);\n  }\n  _close() {\n    let code = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n    let reason = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    if (this.readyState === CONNECTING) {\n      this._requiredToFail = true;\n      if (this._ws !== null) {\n        this._ws.terminate();\n      } else {\n        this._readyState = CLOSING;\n      }\n    } else if (this.readyState === OPEN) {\n      this._ws.close(code, reason);\n    }\n  }\n  send(data) {\n    if (this.readyState === CONNECTING) {\n      throw DOMException.create(this._globalObject, [\"Still in CONNECTING state.\", \"InvalidStateError\"]);\n    }\n    if (this.readyState !== OPEN) {\n      return;\n    }\n    if (Blob.isImpl(data)) {\n      data = data._buffer;\n    }\n    let length;\n    if (typeof data === \"string\") {\n      length = Buffer.byteLength(data, \"utf8\");\n    } else {\n      length = data.byteLength;\n    }\n    this.bufferedAmount += length;\n    this._sendQueue.push([data, length]);\n    this._scheduleSend();\n  }\n  _actuallySend() {\n    for (const [data, length] of this._sendQueue.splice(0)) {\n      this._ws.send(data, {\n        binary: typeof data !== \"string\"\n      }, () => {\n        this.bufferedAmount -= length;\n      });\n    }\n  }\n  _scheduleSend() {\n    if (this._dequeueScheduled) {\n      return;\n    }\n    this._dequeueScheduled = true;\n    process.nextTick(() => {\n      this._dequeueScheduled = false;\n      this._actuallySend();\n    });\n  }\n}\nsetupForSimpleEventAccessors(WebSocketImpl.prototype, [\"open\", \"message\", \"error\", \"close\"]);\nexports.implementation = WebSocketImpl;","map":{"version":3,"names":["nodeURL","require","DOMException","parseURL","serializeURL","serializeURLOrigin","WebSocket","setupForSimpleEventAccessors","fireAnEvent","isArrayBuffer","copyToArrayBufferInNewRealm","EventTargetImpl","implementation","idlUtils","Blob","CloseEvent","MessageEvent","CONNECTING","OPEN","CLOSING","CLOSED","productions","token","readyStateWSToDOM","verifySecWebSocketProtocol","str","test","PromiseQueues","WeakMap","get","window","cur","undefined","Promise","resolve","openSockets","openingQueues","WebSocketImpl","constructor","globalObject","args","privateData","_this","this","_ownerDocument","implForWrapper","_document","url","protocols","urlRecord","create","_globalObject","scheme","fragment","protocolSet","Set","protocol","lowered","toLowerCase","has","add","_urlRecord","nodeParsedURL","parse","extensions","binaryType","_ws","_readyState","_requiredToFail","bufferedAmount","_sendQueue","openSocketsForWindow","_globalProxy","set","then","_onConnectionClosed","headers","navigator","userAgent","_cookieJar","getCookieStringSync","http","_origin","rejectUnauthorized","_resourceLoader","_strictSSL","once","_onConnectionEstablished","on","_onMessageReceived","bind","arguments","_ref","Array","isArray","cookie","setCookieSync","ignoreError","_makeDisappear","_eventListeners","Object","_close","cleanUpWindow","ws","keys","join","data","isBinary","readyState","dataForEvent","toString","Buffer","concat","type","origin","code","reason","_defaultView","delete","wasClean","close","length","byteLength","terminate","send","isImpl","_buffer","push","_scheduleSend","_actuallySend","splice","binary","_dequeueScheduled","process","nextTick","prototype","exports"],"sources":["/Users/bernard/Downloads/my-app/node_modules/jsdom/lib/jsdom/living/websockets/WebSocket-impl.js"],"sourcesContent":["\"use strict\";\n\nconst nodeURL = require(\"url\");\n\nconst DOMException = require(\"domexception/webidl2js-wrapper\");\nconst { parseURL, serializeURL, serializeURLOrigin } = require(\"whatwg-url\");\nconst WebSocket = require(\"ws\");\n\nconst { setupForSimpleEventAccessors } = require(\"../helpers/create-event-accessor\");\nconst { fireAnEvent } = require(\"../helpers/events\");\nconst { isArrayBuffer } = require(\"../generated/utils\");\nconst { copyToArrayBufferInNewRealm } = require(\"../helpers/binary-data\");\n\nconst EventTargetImpl = require(\"../events/EventTarget-impl\").implementation;\n\nconst idlUtils = require(\"../generated/utils\");\nconst Blob = require(\"../generated/Blob\");\nconst CloseEvent = require(\"../generated/CloseEvent\");\nconst MessageEvent = require(\"../generated/MessageEvent\");\n\nconst CONNECTING = 0;\nconst OPEN = 1;\nconst CLOSING = 2;\nconst CLOSED = 3;\n\nconst productions = {\n  // https://tools.ietf.org/html/rfc7230#section-3.2.6\n  token: /^[!#$%&'*+\\-.^_`|~\\dA-Za-z]+$/\n};\n\nconst readyStateWSToDOM = [];\nreadyStateWSToDOM[WebSocket.CONNECTING] = CONNECTING;\nreadyStateWSToDOM[WebSocket.OPEN] = OPEN;\nreadyStateWSToDOM[WebSocket.CLOSING] = CLOSING;\nreadyStateWSToDOM[WebSocket.CLOSED] = CLOSED;\n\n// https://tools.ietf.org/html/rfc6455#section-4.3\n// See Sec-WebSocket-Protocol-Client, which is for the syntax of an entire header value. This function checks if a\n// single header conforms to the rules.\nfunction verifySecWebSocketProtocol(str) {\n  return productions.token.test(str);\n}\n\nclass PromiseQueues extends WeakMap {\n  get(window) {\n    const cur = super.get(window);\n    return cur !== undefined ? cur : Promise.resolve();\n  }\n}\n\nconst openSockets = new WeakMap();\nconst openingQueues = new PromiseQueues();\n\nclass WebSocketImpl extends EventTargetImpl {\n  constructor(globalObject, args, privateData) {\n    super(globalObject, args, privateData);\n\n    this._ownerDocument = idlUtils.implForWrapper(globalObject._document);\n\n    const url = args[0];\n    let protocols = args[1] !== undefined ? args[1] : [];\n\n    const urlRecord = parseURL(url);\n    if (urlRecord === null) {\n      throw DOMException.create(this._globalObject, [`The URL '${url}' is invalid.`, \"SyntaxError\"]);\n    }\n    if (urlRecord.scheme !== \"ws\" && urlRecord.scheme !== \"wss\") {\n      throw DOMException.create(this._globalObject, [\n        `The URL's scheme must be either 'ws' or 'wss'. '${urlRecord.scheme}' is not allowed.`,\n        \"SyntaxError\"\n      ]);\n    }\n    if (urlRecord.fragment !== null) {\n      throw DOMException.create(this._globalObject, [\n        `The URL contains a fragment identifier ('${urlRecord.fragment}'). Fragment identifiers ` +\n        \"are not allowed in WebSocket URLs.\",\n        \"SyntaxError\"\n      ]);\n    }\n\n    if (typeof protocols === \"string\") {\n      protocols = [protocols];\n    }\n    const protocolSet = new Set();\n    for (const protocol of protocols) {\n      if (!verifySecWebSocketProtocol(protocol)) {\n        throw DOMException.create(this._globalObject, [`The subprotocol '${protocol}' is invalid.`, \"SyntaxError\"]);\n      }\n      const lowered = protocol.toLowerCase();\n      if (protocolSet.has(lowered)) {\n        throw DOMException.create(this._globalObject, [\n          `The subprotocol '${protocol}' is duplicated.`,\n          \"SyntaxError\"\n        ]);\n      }\n      protocolSet.add(lowered);\n    }\n\n    this._urlRecord = urlRecord;\n    this.url = serializeURL(urlRecord);\n    const nodeParsedURL = nodeURL.parse(this.url);\n    this.extensions = \"\";\n\n    this.binaryType = \"blob\";\n\n    this._ws = null;\n    // Used when this._ws has not been initialized yet.\n    this._readyState = CONNECTING;\n    this._requiredToFail = false;\n    this.bufferedAmount = 0;\n    this._sendQueue = [];\n\n    let openSocketsForWindow = openSockets.get(globalObject._globalProxy);\n    if (openSocketsForWindow === undefined) {\n      openSocketsForWindow = new Set();\n      openSockets.set(globalObject._globalProxy, openSocketsForWindow);\n    }\n    openSocketsForWindow.add(this);\n\n    openingQueues.set(this._ownerDocument, openingQueues.get(this._ownerDocument).then(() => new Promise(resolve => {\n      // close() called before _ws has been initialized.\n      if (this._requiredToFail) {\n        resolve();\n        this._readyState = CLOSED;\n        this._onConnectionClosed(1006, \"\");\n        return;\n      }\n\n      this._ws = new WebSocket(this.url, protocols, {\n        headers: {\n          \"user-agent\": globalObject.navigator.userAgent,\n          \"cookie\": this._ownerDocument._cookieJar.getCookieStringSync(nodeParsedURL, { http: true }),\n          \"origin\": globalObject._origin\n        },\n        rejectUnauthorized: globalObject._resourceLoader._strictSSL\n      });\n      this._ws.once(\"open\", () => {\n        resolve();\n        this._onConnectionEstablished();\n      });\n      this._ws.on(\"message\", this._onMessageReceived.bind(this));\n      this._ws.once(\"close\", (...closeArgs) => {\n        resolve();\n        this._onConnectionClosed(...closeArgs);\n      });\n      this._ws.once(\"upgrade\", ({ headers }) => {\n        if (Array.isArray(headers[\"set-cookie\"])) {\n          for (const cookie of headers[\"set-cookie\"]) {\n            this._ownerDocument._cookieJar.setCookieSync(\n              cookie,\n              nodeParsedURL,\n              { http: true, ignoreError: true }\n            );\n          }\n        } else if (headers[\"set-cookie\"] !== undefined) {\n          this._ownerDocument._cookieJar.setCookieSync(\n            headers[\"set-cookie\"],\n            nodeParsedURL,\n            { http: true, ignoreError: true }\n          );\n        }\n      });\n      this._ws.once(\"error\", () => {\n        // The exact error is passed into this callback, but it is ignored as we don't really care about it.\n        resolve();\n        this._requiredToFail = true;\n        // Do not emit an error here, as that will be handled in _onConnectionClosed. ws always emits a close event\n        // after errors.\n      });\n    })));\n  }\n\n  // https://html.spec.whatwg.org/multipage/web-sockets.html#make-disappear\n  _makeDisappear() {\n    this._eventListeners = Object.create(null);\n    this._close(1001);\n  }\n\n  static cleanUpWindow(window) {\n    const openSocketsForWindow = openSockets.get(window._globalProxy);\n    if (openSocketsForWindow !== undefined) {\n      for (const ws of openSocketsForWindow) {\n        ws._makeDisappear();\n      }\n    }\n  }\n\n  // https://html.spec.whatwg.org/multipage/web-sockets.html#feedback-from-the-protocol\n  _onConnectionEstablished() {\n    // readyState is a getter.\n    if (this._ws.extensions !== null) {\n      // Right now, ws only supports one extension, permessage-deflate, without any parameters. This algorithm may need\n      // to be more sophiscated as more extenions are supported.\n      this.extensions = Object.keys(this._ws.extensions).join(\", \");\n    }\n    // protocol is a getter.\n    fireAnEvent(\"open\", this);\n  }\n\n  _onMessageReceived(data, isBinary) {\n    if (this.readyState !== OPEN) {\n      return;\n    }\n    let dataForEvent;\n    if (!isBinary) {\n      dataForEvent = data.toString();\n    } else if (this.binaryType === \"arraybuffer\") {\n      if (isArrayBuffer(data)) {\n        dataForEvent = data;\n      } else if (Array.isArray(data)) {\n        dataForEvent = copyToArrayBufferInNewRealm(Buffer.concat(data), this._globalObject);\n      } else {\n        dataForEvent = copyToArrayBufferInNewRealm(data, this._globalObject);\n      }\n    } else { // this.binaryType === \"blob\"\n      if (!Array.isArray(data)) {\n        data = [data];\n      }\n      dataForEvent = Blob.create(this._globalObject, [data, { type: \"\" }]);\n    }\n    fireAnEvent(\"message\", this, MessageEvent, {\n      data: dataForEvent,\n      origin: serializeURLOrigin(this._urlRecord)\n    });\n  }\n\n  _onConnectionClosed(code, reason) {\n    const openSocketsForWindow = openSockets.get(this._ownerDocument._defaultView);\n    openSocketsForWindow.delete(this);\n\n    const wasClean = !this._requiredToFail;\n    if (this._requiredToFail) {\n      fireAnEvent(\"error\", this);\n    }\n    fireAnEvent(\"close\", this, CloseEvent, {\n      wasClean,\n      code,\n      reason: reason.toString()\n    });\n  }\n\n  get readyState() {\n    if (this._ws !== null) {\n      return readyStateWSToDOM[this._ws.readyState];\n    }\n    return this._readyState;\n  }\n\n  get protocol() {\n    if (this._ws === null) {\n      return \"\";\n    }\n    return this._ws.protocol;\n  }\n\n  close(code = undefined, reason = undefined) {\n    if (code !== undefined && code !== 1000 && !(code >= 3000 && code <= 4999)) {\n      throw DOMException.create(this._globalObject, [\n        `The code must be either 1000, or between 3000 and 4999. ${code} is neither.`,\n        \"InvalidAccessError\"\n      ]);\n    }\n    if (reason !== undefined && Buffer.byteLength(reason, \"utf8\") > 123) {\n      throw DOMException.create(this._globalObject, [\n        \"The message must not be greater than 123 bytes.\",\n        \"SyntaxError\"\n      ]);\n    }\n    this._close(code, reason);\n  }\n\n  _close(code = undefined, reason = undefined) {\n    if (this.readyState === CONNECTING) {\n      this._requiredToFail = true;\n      if (this._ws !== null) {\n        this._ws.terminate();\n      } else {\n        this._readyState = CLOSING;\n      }\n    } else if (this.readyState === OPEN) {\n      this._ws.close(code, reason);\n    }\n  }\n\n  send(data) {\n    if (this.readyState === CONNECTING) {\n      throw DOMException.create(this._globalObject, [\"Still in CONNECTING state.\", \"InvalidStateError\"]);\n    }\n    if (this.readyState !== OPEN) {\n      return;\n    }\n    if (Blob.isImpl(data)) {\n      data = data._buffer;\n    }\n    let length;\n    if (typeof data === \"string\") {\n      length = Buffer.byteLength(data, \"utf8\");\n    } else {\n      length = data.byteLength;\n    }\n    this.bufferedAmount += length;\n    this._sendQueue.push([data, length]);\n    this._scheduleSend();\n  }\n\n  _actuallySend() {\n    for (const [data, length] of this._sendQueue.splice(0)) {\n      this._ws.send(data, { binary: typeof data !== \"string\" }, () => {\n        this.bufferedAmount -= length;\n      });\n    }\n  }\n\n  _scheduleSend() {\n    if (this._dequeueScheduled) {\n      return;\n    }\n    this._dequeueScheduled = true;\n    process.nextTick(() => {\n      this._dequeueScheduled = false;\n      this._actuallySend();\n    });\n  }\n}\n\nsetupForSimpleEventAccessors(WebSocketImpl.prototype, [\"open\", \"message\", \"error\", \"close\"]);\n\nexports.implementation = WebSocketImpl;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}