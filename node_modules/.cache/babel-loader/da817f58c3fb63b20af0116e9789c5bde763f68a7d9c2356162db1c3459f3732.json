{"ast":null,"code":"\"use strict\";\n\nconst {\n  isForbidden,\n  isForbiddenResponse,\n  isPrivilegedNoCORSRequest,\n  isNoCORSSafelistedRequest,\n  isCORSWhitelisted\n} = require(\"./header-types\");\nconst HeaderList = require(\"./header-list\");\nfunction assertName(name) {\n  if (!name.match(/^[!#$%&'*+\\-.^`|~\\w]+$/)) {\n    throw new TypeError(\"name is invalid\");\n  }\n}\nfunction assertValue(value) {\n  if (value.match(/[\\0\\r\\n]/)) {\n    throw new TypeError(\"value is invalid\");\n  }\n}\n\n// https://fetch.spec.whatwg.org/#concept-header-value-normalize\nfunction normalizeValue(potentialValue) {\n  return potentialValue.replace(/^[\\n\\r\\t ]+|[\\n\\r\\t ]+$/g, \"\");\n}\nclass HeadersImpl {\n  constructor(globalObject, args) {\n    this.guard = \"none\";\n    this.headersList = new HeaderList();\n    if (args[0]) {\n      this._fill(args[0]);\n    }\n  }\n  _fill(init) {\n    if (Array.isArray(init)) {\n      for (const header of init) {\n        if (header.length !== 2) {\n          throw new TypeError(\"init is invalid\");\n        }\n        this.append(header[0], header[1]);\n      }\n    } else {\n      for (const key of Object.keys(init)) {\n        this.append(key, init[key]);\n      }\n    }\n  }\n  has(name) {\n    assertName(name);\n    return this.headersList.contains(name);\n  }\n  get(name) {\n    assertName(name);\n    return this.headersList.get(name);\n  }\n  _removePrivilegedNoCORSHeaders() {\n    this.headersList.delete(\"range\");\n  }\n  append(name, value) {\n    value = normalizeValue(value);\n    assertName(name);\n    assertValue(value);\n    switch (this.guard) {\n      case \"immutable\":\n        throw new TypeError(\"Headers is immutable\");\n      case \"request\":\n        if (isForbidden(name)) {\n          return;\n        }\n        break;\n      case \"request-no-cors\":\n        {\n          let temporaryValue = this.get(name);\n          if (temporaryValue === null) {\n            temporaryValue = value;\n          } else {\n            temporaryValue += `, ${value}`;\n          }\n          if (!isCORSWhitelisted(name, value)) {\n            return;\n          }\n          break;\n        }\n      case \"response\":\n        if (isForbiddenResponse(name)) {\n          return;\n        }\n        break;\n    }\n    this.headersList.append(name, value);\n    this._removePrivilegedNoCORSHeaders();\n  }\n  set(name, value) {\n    value = normalizeValue(value);\n    assertName(name);\n    assertValue(value);\n    switch (this.guard) {\n      case \"immutable\":\n        throw new TypeError(\"Headers is immutable\");\n      case \"request\":\n        if (isForbidden(name)) {\n          return;\n        }\n        break;\n      case \"request-no-cors\":\n        {\n          if (!isCORSWhitelisted(name, value)) {\n            return;\n          }\n          break;\n        }\n      case \"response\":\n        if (isForbiddenResponse(name)) {\n          return;\n        }\n        break;\n    }\n    this.headersList.set(name, value);\n    this._removePrivilegedNoCORSHeaders();\n  }\n  delete(name) {\n    assertName(name);\n    switch (this.guard) {\n      case \"immutable\":\n        throw new TypeError(\"Headers is immutable\");\n      case \"request\":\n        if (isForbidden(name)) {\n          return;\n        }\n        break;\n      case \"request-no-cors\":\n        {\n          if (!isNoCORSSafelistedRequest(name) && !isPrivilegedNoCORSRequest(name)) {\n            return;\n          }\n          break;\n        }\n      case \"response\":\n        if (isForbiddenResponse(name)) {\n          return;\n        }\n        break;\n    }\n    this.headersList.delete(name);\n    this._removePrivilegedNoCORSHeaders();\n  }\n  *[Symbol.iterator]() {\n    for (const header of this.headersList.sortAndCombine()) {\n      yield header;\n    }\n  }\n}\nexports.implementation = HeadersImpl;","map":{"version":3,"names":["isForbidden","isForbiddenResponse","isPrivilegedNoCORSRequest","isNoCORSSafelistedRequest","isCORSWhitelisted","require","HeaderList","assertName","name","match","TypeError","assertValue","value","normalizeValue","potentialValue","replace","HeadersImpl","constructor","globalObject","args","guard","headersList","_fill","init","Array","isArray","header","length","append","key","Object","keys","has","contains","get","_removePrivilegedNoCORSHeaders","delete","temporaryValue","set","Symbol","iterator","sortAndCombine","exports","implementation"],"sources":["/Users/bernard/Downloads/my-app/node_modules/jsdom/lib/jsdom/living/fetch/Headers-impl.js"],"sourcesContent":["\"use strict\";\n\nconst {\n  isForbidden,\n  isForbiddenResponse,\n  isPrivilegedNoCORSRequest,\n  isNoCORSSafelistedRequest,\n  isCORSWhitelisted\n} = require(\"./header-types\");\nconst HeaderList = require(\"./header-list\");\n\nfunction assertName(name) {\n  if (!name.match(/^[!#$%&'*+\\-.^`|~\\w]+$/)) {\n    throw new TypeError(\"name is invalid\");\n  }\n}\n\nfunction assertValue(value) {\n  if (value.match(/[\\0\\r\\n]/)) {\n    throw new TypeError(\"value is invalid\");\n  }\n}\n\n// https://fetch.spec.whatwg.org/#concept-header-value-normalize\nfunction normalizeValue(potentialValue) {\n  return potentialValue.replace(/^[\\n\\r\\t ]+|[\\n\\r\\t ]+$/g, \"\");\n}\n\nclass HeadersImpl {\n  constructor(globalObject, args) {\n    this.guard = \"none\";\n    this.headersList = new HeaderList();\n\n    if (args[0]) {\n      this._fill(args[0]);\n    }\n  }\n\n  _fill(init) {\n    if (Array.isArray(init)) {\n      for (const header of init) {\n        if (header.length !== 2) {\n          throw new TypeError(\"init is invalid\");\n        }\n        this.append(header[0], header[1]);\n      }\n    } else {\n      for (const key of Object.keys(init)) {\n        this.append(key, init[key]);\n      }\n    }\n  }\n\n  has(name) {\n    assertName(name);\n    return this.headersList.contains(name);\n  }\n\n  get(name) {\n    assertName(name);\n    return this.headersList.get(name);\n  }\n\n  _removePrivilegedNoCORSHeaders() {\n    this.headersList.delete(\"range\");\n  }\n\n  append(name, value) {\n    value = normalizeValue(value);\n    assertName(name);\n    assertValue(value);\n\n    switch (this.guard) {\n      case \"immutable\":\n        throw new TypeError(\"Headers is immutable\");\n      case \"request\":\n        if (isForbidden(name)) {\n          return;\n        }\n        break;\n      case \"request-no-cors\": {\n        let temporaryValue = this.get(name);\n        if (temporaryValue === null) {\n          temporaryValue = value;\n        } else {\n          temporaryValue += `, ${value}`;\n        }\n        if (!isCORSWhitelisted(name, value)) {\n          return;\n        }\n        break;\n      }\n      case \"response\":\n        if (isForbiddenResponse(name)) {\n          return;\n        }\n        break;\n    }\n\n    this.headersList.append(name, value);\n    this._removePrivilegedNoCORSHeaders();\n  }\n\n  set(name, value) {\n    value = normalizeValue(value);\n    assertName(name);\n    assertValue(value);\n\n    switch (this.guard) {\n      case \"immutable\":\n        throw new TypeError(\"Headers is immutable\");\n      case \"request\":\n        if (isForbidden(name)) {\n          return;\n        }\n        break;\n      case \"request-no-cors\": {\n        if (!isCORSWhitelisted(name, value)) {\n          return;\n        }\n        break;\n      }\n      case \"response\":\n        if (isForbiddenResponse(name)) {\n          return;\n        }\n        break;\n    }\n    this.headersList.set(name, value);\n    this._removePrivilegedNoCORSHeaders();\n  }\n\n  delete(name) {\n    assertName(name);\n\n    switch (this.guard) {\n      case \"immutable\":\n        throw new TypeError(\"Headers is immutable\");\n      case \"request\":\n        if (isForbidden(name)) {\n          return;\n        }\n        break;\n      case \"request-no-cors\": {\n        if (\n          !isNoCORSSafelistedRequest(name) &&\n          !isPrivilegedNoCORSRequest(name)\n        ) {\n          return;\n        }\n        break;\n      }\n      case \"response\":\n        if (isForbiddenResponse(name)) {\n          return;\n        }\n        break;\n    }\n    this.headersList.delete(name);\n    this._removePrivilegedNoCORSHeaders();\n  }\n\n  * [Symbol.iterator]() {\n    for (const header of this.headersList.sortAndCombine()) {\n      yield header;\n    }\n  }\n}\n\nexports.implementation = HeadersImpl;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}