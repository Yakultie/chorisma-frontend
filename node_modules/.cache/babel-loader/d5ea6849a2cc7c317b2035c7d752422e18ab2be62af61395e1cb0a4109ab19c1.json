{"ast":null,"code":"\"use strict\";\n\nconst fs = require(\"fs\");\nconst {\n  fileURLToPath\n} = require(\"url\");\nconst {\n  parseURL\n} = require(\"whatwg-url\");\nconst dataURLFromRecord = require(\"data-urls\").fromURLRecord;\nconst packageVersion = require(\"../../../../package.json\").version;\nconst agentFactory = require(\"../../living/helpers/agent-factory\");\nconst Request = require(\"../../living/helpers/http-request\");\nconst IS_BROWSER = Object.prototype.toString.call(process) !== \"[object process]\";\nmodule.exports = class ResourceLoader {\n  constructor() {\n    let {\n      strictSSL = true,\n      proxy = undefined,\n      userAgent = `Mozilla/5.0 (${process.platform || \"unknown OS\"}) AppleWebKit/537.36 ` + `(KHTML, like Gecko) jsdom/${packageVersion}`\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this._strictSSL = strictSSL;\n    this._proxy = proxy;\n    this._userAgent = userAgent;\n  }\n  _readDataURL(urlRecord) {\n    const dataURL = dataURLFromRecord(urlRecord);\n    let timeoutId;\n    const promise = new Promise(resolve => {\n      timeoutId = setTimeout(resolve, 0, Buffer.from(dataURL.body));\n    });\n    promise.abort = () => {\n      if (timeoutId !== undefined) {\n        clearTimeout(timeoutId);\n      }\n    };\n    return promise;\n  }\n  _readFile(filePath) {\n    let readableStream, abort; // Native Promises doesn't have an \"abort\" method.\n\n    // Creating a promise for two reason:\n    //   1. fetch always return a promise.\n    //   2. We need to add an abort handler.\n    const promise = new Promise((resolve, reject) => {\n      readableStream = fs.createReadStream(filePath);\n      let data = Buffer.alloc(0);\n      abort = reject;\n      readableStream.on(\"error\", reject);\n      readableStream.on(\"data\", chunk => {\n        data = Buffer.concat([data, chunk]);\n      });\n      readableStream.on(\"end\", () => {\n        resolve(data);\n      });\n    });\n    promise.abort = () => {\n      readableStream.destroy();\n      const error = new Error(\"request canceled by user\");\n      error.isAbortError = true;\n      abort(error);\n    };\n    return promise;\n  }\n  fetch(urlString) {\n    let {\n      accept,\n      cookieJar,\n      referrer\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const url = parseURL(urlString);\n    if (!url) {\n      return Promise.reject(new Error(`Tried to fetch invalid URL ${urlString}`));\n    }\n    switch (url.scheme) {\n      case \"data\":\n        {\n          return this._readDataURL(url);\n        }\n      case \"http\":\n      case \"https\":\n        {\n          const agents = agentFactory(this._proxy, this._strictSSL);\n          const headers = {\n            \"User-Agent\": this._userAgent,\n            \"Accept-Language\": \"en\",\n            \"Accept-Encoding\": \"gzip\",\n            \"Accept\": accept || \"*/*\"\n          };\n          if (referrer && !IS_BROWSER) {\n            headers.Referer = referrer;\n          }\n          const requestClient = new Request(urlString, {\n            followRedirects: true,\n            cookieJar,\n            agents\n          }, {\n            headers\n          });\n          const promise = new Promise((resolve, reject) => {\n            const accumulated = [];\n            requestClient.once(\"response\", res => {\n              promise.response = res;\n              const {\n                statusCode\n              } = res;\n              // TODO This deviates from the spec when it comes to\n              // loading resources such as images\n              if (statusCode < 200 || statusCode > 299) {\n                requestClient.abort();\n                reject(new Error(`Resource was not loaded. Status: ${statusCode}`));\n              }\n            });\n            requestClient.on(\"data\", chunk => {\n              accumulated.push(chunk);\n            });\n            requestClient.on(\"end\", () => resolve(Buffer.concat(accumulated)));\n            requestClient.on(\"error\", reject);\n          });\n          // The method fromURL in lib/api.js crashes without the following four\n          // properties defined on the Promise instance, causing the test suite to halt\n          requestClient.on(\"end\", () => {\n            promise.href = requestClient.currentURL;\n          });\n          promise.abort = requestClient.abort.bind(requestClient);\n          promise.getHeader = name => headers[name] || requestClient.getHeader(name);\n          requestClient.end();\n          return promise;\n        }\n      case \"file\":\n        {\n          try {\n            return this._readFile(fileURLToPath(urlString));\n          } catch (e) {\n            return Promise.reject(e);\n          }\n        }\n      default:\n        {\n          return Promise.reject(new Error(`Tried to fetch URL ${urlString} with invalid scheme ${url.scheme}`));\n        }\n    }\n  }\n};","map":{"version":3,"names":["fs","require","fileURLToPath","parseURL","dataURLFromRecord","fromURLRecord","packageVersion","version","agentFactory","Request","IS_BROWSER","Object","prototype","toString","call","process","module","exports","ResourceLoader","constructor","strictSSL","proxy","undefined","userAgent","platform","arguments","length","_strictSSL","_proxy","_userAgent","_readDataURL","urlRecord","dataURL","timeoutId","promise","Promise","resolve","setTimeout","Buffer","from","body","abort","clearTimeout","_readFile","filePath","readableStream","reject","createReadStream","data","alloc","on","chunk","concat","destroy","error","Error","isAbortError","fetch","urlString","accept","cookieJar","referrer","url","scheme","agents","headers","Referer","requestClient","followRedirects","accumulated","once","res","response","statusCode","push","href","currentURL","bind","getHeader","name","end","e"],"sources":["/Users/bernard/Downloads/my-app/node_modules/jsdom/lib/jsdom/browser/resources/resource-loader.js"],"sourcesContent":["\"use strict\";\nconst fs = require(\"fs\");\nconst { fileURLToPath } = require(\"url\");\nconst { parseURL } = require(\"whatwg-url\");\nconst dataURLFromRecord = require(\"data-urls\").fromURLRecord;\nconst packageVersion = require(\"../../../../package.json\").version;\nconst agentFactory = require(\"../../living/helpers/agent-factory\");\nconst Request = require(\"../../living/helpers/http-request\");\n\nconst IS_BROWSER = Object.prototype.toString.call(process) !== \"[object process]\";\n\nmodule.exports = class ResourceLoader {\n  constructor({\n    strictSSL = true,\n    proxy = undefined,\n    userAgent = `Mozilla/5.0 (${process.platform || \"unknown OS\"}) AppleWebKit/537.36 ` +\n                `(KHTML, like Gecko) jsdom/${packageVersion}`\n  } = {}) {\n    this._strictSSL = strictSSL;\n    this._proxy = proxy;\n    this._userAgent = userAgent;\n  }\n\n  _readDataURL(urlRecord) {\n    const dataURL = dataURLFromRecord(urlRecord);\n    let timeoutId;\n    const promise = new Promise(resolve => {\n      timeoutId = setTimeout(resolve, 0, Buffer.from(dataURL.body));\n    });\n    promise.abort = () => {\n      if (timeoutId !== undefined) {\n        clearTimeout(timeoutId);\n      }\n    };\n    return promise;\n  }\n\n  _readFile(filePath) {\n    let readableStream, abort; // Native Promises doesn't have an \"abort\" method.\n\n    // Creating a promise for two reason:\n    //   1. fetch always return a promise.\n    //   2. We need to add an abort handler.\n    const promise = new Promise((resolve, reject) => {\n      readableStream = fs.createReadStream(filePath);\n      let data = Buffer.alloc(0);\n\n      abort = reject;\n\n      readableStream.on(\"error\", reject);\n\n      readableStream.on(\"data\", chunk => {\n        data = Buffer.concat([data, chunk]);\n      });\n\n      readableStream.on(\"end\", () => {\n        resolve(data);\n      });\n    });\n\n    promise.abort = () => {\n      readableStream.destroy();\n      const error = new Error(\"request canceled by user\");\n      error.isAbortError = true;\n      abort(error);\n    };\n\n    return promise;\n  }\n\n  fetch(urlString, { accept, cookieJar, referrer } = {}) {\n    const url = parseURL(urlString);\n\n    if (!url) {\n      return Promise.reject(new Error(`Tried to fetch invalid URL ${urlString}`));\n    }\n\n    switch (url.scheme) {\n      case \"data\": {\n        return this._readDataURL(url);\n      }\n\n      case \"http\":\n      case \"https\": {\n        const agents = agentFactory(this._proxy, this._strictSSL);\n        const headers = {\n          \"User-Agent\": this._userAgent,\n          \"Accept-Language\": \"en\",\n          \"Accept-Encoding\": \"gzip\",\n          \"Accept\": accept || \"*/*\"\n        };\n        if (referrer && !IS_BROWSER) {\n          headers.Referer = referrer;\n        }\n        const requestClient = new Request(\n          urlString,\n          { followRedirects: true, cookieJar, agents },\n          { headers }\n        );\n        const promise = new Promise((resolve, reject) => {\n          const accumulated = [];\n          requestClient.once(\"response\", res => {\n            promise.response = res;\n            const { statusCode } = res;\n            // TODO This deviates from the spec when it comes to\n            // loading resources such as images\n            if (statusCode < 200 || statusCode > 299) {\n              requestClient.abort();\n              reject(new Error(`Resource was not loaded. Status: ${statusCode}`));\n            }\n          });\n          requestClient.on(\"data\", chunk => {\n            accumulated.push(chunk);\n          });\n          requestClient.on(\"end\", () => resolve(Buffer.concat(accumulated)));\n          requestClient.on(\"error\", reject);\n        });\n        // The method fromURL in lib/api.js crashes without the following four\n        // properties defined on the Promise instance, causing the test suite to halt\n        requestClient.on(\"end\", () => {\n          promise.href = requestClient.currentURL;\n        });\n        promise.abort = requestClient.abort.bind(requestClient);\n        promise.getHeader = name => headers[name] || requestClient.getHeader(name);\n        requestClient.end();\n        return promise;\n      }\n\n      case \"file\": {\n        try {\n          return this._readFile(fileURLToPath(urlString));\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n\n      default: {\n        return Promise.reject(new Error(`Tried to fetch URL ${urlString} with invalid scheme ${url.scheme}`));\n      }\n    }\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}